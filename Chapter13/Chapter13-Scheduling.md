
<div dir="rtl" align="right">


# فصل ۱۳. برنامه‌ریزی

هنگامی که یک قطعه کد اجرا می‌شود، باید در یک رشته خاص در جایی اجرا شود. یک برنامه‌ریز (scheduler) یک شیء است که تصمیم می‌گیرد یک قطعه کد خاص در کجا اجرا شود. در چارچوب .NET چند نوع برنامه‌ریز مختلف وجود دارد که با تفاوت‌های جزئی توسط کدهای موازی و جریان داده استفاده می‌شوند.

توصیه می‌کنم تا جایی که ممکن است یک برنامه‌ریز را مشخص نکنید؛ مقادیر پیش‌فرض معمولاً درست هستند. برای مثال، عملگر `await` در کد ناهمگام به طور خودکار متد را در همان متن دوباره اجرا می‌کند مگر اینکه این پیش‌فرض را لغو کنید، همانطور که در نسخه ۲.۷ توضیح داده شده است. به همین ترتیب، کد واکنشی دارای متن‌های پیش‌فرض معقولی برای رویدادهای خود است که می‌توانید آن‌ها را با `ObserveOn`، همانطور که در نسخه ۶.۲ توضیح داده شده، لغو کنید.

اگر نیاز دارید کد دیگری در یک متن خاص (مثلاً متن رشته UI یا متن درخواست ASP.NET) اجرا شود، می‌توانید از دستورات برنامه‌ریزی در این فصل برای کنترل برنامه‌ریزی کد خود استفاده کنید.

## ۱۳.۱ برنامه‌ریزی کار برای استخر رشته

### مسئله

شما یک قطعه کد دارید که می‌خواهید به صراحت آن را در یک رشته استخر رشته اجرا کنید.

### راه‌حل

اکثر اوقات، شما می‌خواهید از `Task.Run` استفاده کنید که بسیار ساده است. کد زیر یک رشته استخر رشته را برای ۲ ثانیه مسدود می‌کند:


</div>

<div dir="ltr" align="left">


```csharp
Task task = Task.Run(() =>
{
    Thread.Sleep(TimeSpan.FromSeconds(2));
});

```

</div>

<div dir="rtl" align="right">


`Task.Run` همچنین مقادیر بازگشتی و لامبداهای ناهمگام را به خوبی درک می‌کند. کار بازگردانده شده توسط `Task.Run` در کد زیر پس از ۲ ثانیه با نتیجه ۱۳ کامل خواهد شد:

</div>

<div dir="ltr" align="left">



```csharp
Task<int> task = Task.Run(async () =>
{
    await Task.Delay(TimeSpan.FromSeconds(2));
    return 13;
});

```
</div>

<div dir="rtl" align="right">


`Task.Run` یک `Task` (یا `Task<T>`) را برمی‌گرداند که به طور طبیعی توسط کدهای ناهمگام یا واکنشی قابل مصرف است.

### بحث

`Task.Run` برای برنامه‌های کاربردی UI ایده‌آل است، زمانی که کار زمان‌بر را دارید که نمی‌توان آن را در رشته UI انجام داد. برای مثال، نسخه ۸.۴ از `Task.Run` برای هل دادن پردازش موازی به یک رشته استخر رشته استفاده می‌کند. با این حال، در ASP.NET از `Task.Run` استفاده نکنید مگر اینکه کاملاً مطمئن باشید که چه می‌کنید. در ASP.NET، کد مدیریت درخواست از قبل در یک رشته استخر رشته اجرا می‌شود، بنابراین هل دادن آن به رشته استخر رشته دیگر معمولاً ناکارآمد است.

`Task.Run` جایگزین مؤثری برای `BackgroundWorker`، `Delegate.BeginInvoke` و `ThreadPool.QueueUserWorkItem` است. هیچ یک از این APIهای قدیمی‌تر نباید در کدهای جدید استفاده شوند؛ کد با استفاده از `Task.Run` بسیار راحت‌تر می‌توان آن را به درستی نوشت و در طول زمان نگهداری کرد. علاوه بر این، `Task.Run` اکثر موارد استفاده را برای `Thread` پوشش می‌دهد، بنابراین اکثر استفاده‌های `Thread` می‌توانند با `Task.Run` جایگزین شوند (با استثنای نادر رشته‌های آپارتمان تک رشته‌ای).

کدهای موازی و جریان داده به طور پیش‌فرض در استخر رشته اجرا می‌شوند، بنابراین معمولاً نیازی به استفاده از `Task.Run` با کدهای اجرا شده توسط کتابخانه‌های Parallel، Parallel LINQ یا TPL Dataflow نیست.

اگر در حال انجام موازی‌سازی پویا هستید، از `Task.Factory.StartNew` به جای `Task.Run` استفاده کنید. این به این دلیل ضروری است که `Task` بازگردانده شده توسط `Task.Run` با گزینه‌های پیش‌فرض برای استفاده ناهمگام پیکربندی شده است (یعنی برای مصرف توسط کد ناهمگام یا واکنشی). همچنین از مفاهیم پیشرفته‌ای مانند وظایف والد/فرزند که در کدهای موازی پویا رایج‌تر هستند، پشتیبانی نمی‌کند.

### مراجعه کنید به

 نسخه ۸.۶ مصرف کد ناهمگام (مانند کار بازگردانده شده از `Task.Run`) با کد واکنشی را پوشش می‌دهد.

 نسخه ۸.۴ انتظار ناهمگام برای کد موازی را پوشش می‌دهد که به راحتی از طریق `Task.Run` انجام می‌شود.

 نسخه ۴.۴ موازی‌سازی پویا را پوشش می‌دهد، سناریویی که در آن باید از `Task.Factory.StartNew` به جای `Task.Run` استفاده کنید.






## ۱۳.۲ اجرای کد با یک برنامه‌ریز وظیفه

### مسئله

شما چندین قطعه کد دارید که باید آن‌ها را به روشی خاص اجرا کنید. برای مثال، ممکن است نیاز داشته باشید همه قطعات کد در رشته UI اجرا شوند، یا فقط تعداد معینی را هر بار اجرا کنید.

این دستورالعمل در مورد چگونگی تعریف و ساخت یک برنامه‌ریز برای این قطعات کد است. اعمال واقعی آن برنامه‌ریز موضوع دو دستورالعمل بعدی است.

### راه‌حل

در .NET انواع مختلفی وجود دارند که می‌توانند برنامه‌ریزی را مدیریت کنند؛ این دستورالعمل بر `TaskScheduler` تمرکز می‌کند زیرا قابل حمل و نسبتاً آسان در استفاده است.

ساده‌ترین `TaskScheduler`، `TaskScheduler.Default` است که کارها را در استخر رشته صف می‌کند. شما به ندرت `TaskScheduler.Default` را در کد خود مشخص خواهید کرد، اما مهم است که از آن آگاه باشید، زیرا پیش‌فرض برای بسیاری از سناریوهای برنامه‌ریزی است. `Task.Run`، کدهای موازی و جریان داده همگی از `TaskScheduler.Default` استفاده می‌کنند.

می‌توانید یک متن خاص را دریافت و سپس کار را دوباره به آن برنامه‌ریزی کنید با استفاده از `TaskScheduler.FromCurrentSynchronizationContext`:

</div>

<div dir="ltr" align="left">


```csharp
TaskScheduler scheduler = TaskScheduler.FromCurrentSynchronizationContext();
```
</div>

<div dir="rtl" align="right">


این کد یک `TaskScheduler` ایجاد می‌کند تا `SynchronizationContext` فعلی را دریافت و کد را در آن متن برنامه‌ریزی کند.

`SynchronizationContext` یک نوع است که یک متن برنامه‌ریزی عمومی را نشان می‌دهد. چندین متن مختلف در چارچوب .NET وجود دارد؛ اکثر چارچوب‌های UI یک `SynchronizationContext` ارائه می‌دهند که رشته UI را نشان می‌دهد، و ASP.NET قبل از Core یک `SynchronizationContext` ارائه می‌داد که متن درخواست HTTP را نشان می‌داد.

`ConcurrentExclusiveSchedulerPair` یک نوع قدرتمند دیگر معرفی شده در .NET 4.5 است؛ این در واقع دو برنامه‌ریز مرتبط با هم است. عضو `ConcurrentScheduler` یک برنامه‌ریز است که اجازه می‌دهد چندین وظیفه همزمان اجرا شوند، تا زمانی که هیچ وظیفه‌ای در `ExclusiveScheduler` در حال اجرا نباشد. `ExclusiveScheduler` فقط کد را یک وظیفه در یک زمان اجرا می‌کند، و فقط زمانی که هیچ وظیفه‌ای در حال اجرا در `ConcurrentScheduler` نیست:

</div>

<div dir="ltr" align="left">


```csharp
var schedulerPair = new ConcurrentExclusiveSchedulerPair();
TaskScheduler concurrent = schedulerPair.ConcurrentScheduler;
TaskScheduler exclusive = schedulerPair.ExclusiveScheduler;
```
</div>

<div dir="rtl" align="right">


یک استفاده رایج از `ConcurrentExclusiveSchedulerPair` فقط استفاده از `ExclusiveScheduler` برای اطمینان از اجرای یک وظیفه در هر زمان است. کدی که در `ExclusiveScheduler` اجرا می‌شود در استخر رشته اجرا خواهد شد اما محدود به اجرای انحصاری نسبت به تمام کدهای دیگر با استفاده از همان نمونه `ExclusiveScheduler` خواهد بود.

کاربرد دیگر `ConcurrentExclusiveSchedulerPair` به عنوان یک برنامه‌ریز محدودکننده است. می‌توانید یک `ConcurrentExclusiveSchedulerPair` ایجاد کنید که همزمانی خود را محدود کند. در این سناریو، معمولاً از `ExclusiveScheduler` استفاده نمی‌شود:

</div>

<div dir="ltr" align="left">


```csharp
var schedulerPair = new ConcurrentExclusiveSchedulerPair(
    TaskScheduler.Default, maxConcurrencyLevel: 8);
TaskScheduler scheduler = schedulerPair.ConcurrentScheduler;
```

</div>

<div dir="rtl" align="right">


توجه کنید که این نوع محدودسازی فقط کد را در حال اجرا محدود می‌کند؛ این بسیار متفاوت از نوع محدودسازی منطقی پوشش داده شده در نسخه ۱۲.۵ است. به طور خاص، کد ناهمگام در حالی که در انتظار یک عملیات است، در حال اجرا محسوب نمی‌شود. `ConcurrentScheduler` کد در حال اجرا را محدود می‌کند؛ محدودسازی‌های دیگر، مانند `SemaphoreSlim`، در سطح بالاتر (یعنی یک متد async کامل) محدود می‌شوند.

### بحث

ممکن است متوجه شده باشید که مثال کد آخر `TaskScheduler.Default` را به سازنده `ConcurrentExclusiveSchedulerPair` ارسال کرد. این به این دلیل است که `ConcurrentExclusiveSchedulerPair` منطق همزمان/انحصاری خود را در اطراف یک `TaskScheduler` موجود اعمال می‌کند.

این دستورالعمل `TaskScheduler.FromCurrentSynchronizationContext` را معرفی می‌کند که برای اجرای کد در یک متن دریافت شده مفید است. همچنین امکان استفاده مستقیم از `SynchronizationContext` برای اجرای کد در آن متن وجود دارد؛ با این حال، این رویکرد را توصیه نمی‌کنم. هر زمان که ممکن است، از عملگر `await` برای ادامه در یک متن به طور ضمنی دریافت شده استفاده کنید یا از یک پوشش `TaskScheduler` استفاده کنید.

هرگز از انواع مختص پلتفرم برای اجرای کد در رشته UI استفاده نکنید. WPF، Silverlight، iOS و Android همگی نوع `Dispatcher` را ارائه می‌دهند، Universal Windows از `CoreDispatcher` استفاده می‌کند، و Windows Forms رابط `ISynchronizeInvoke` (یعنی `Control.Invoke`) را دارد. از هیچ یک از این انواع در کدهای جدید استفاده نکنید؛ فقط وانمود کنید که وجود ندارند. استفاده از آن‌ها کد شما را بیهوده به یک پلتفرم خاص وابسته می‌کند. `SynchronizationContext` یک انتزاع عمومی در اطراف این انواع است.

`System.Reactive (Rx)` یک انتزاع برنامه‌ریز عمومی‌تر معرفی می‌کند: `IScheduler`. یک برنامه‌ریز Rx قادر به پوشش هر نوع برنامه‌ریز دیگری است؛ `TaskPoolScheduler` هر `TaskFactory` (که شامل یک `TaskScheduler` است) را پوشش می‌دهد. تیم Rx همچنین یک اجرای `IScheduler` را تعریف کرده است که برای آزمایش به صورت دستی کنترل می‌شود. اگر نیاز به استفاده از یک انتزاع برنامه‌ریز دارید، `IScheduler` از Rx را توصیه می‌کنم؛ آن خوب طراحی شده، خوب تعریف شده و برای آزمایش دوستانه است. با این حال، اکثر اوقات به یک انتزاع برنامه‌ریز نیاز ندارید و کتابخانه‌های قدیمی‌تر، مانند `Task Parallel Library (TPL)` و `TPL Dataflow`، فقط نوع `TaskScheduler` را درک می‌کنند.

### مراجعه کنید به

- نسخه ۱۳.۳ اعمال `TaskScheduler` به کد موازی را پوشش می‌دهد.
- نسخه ۱۳.۴ اعمال `TaskScheduler` به کد جریان داده را پوشش می‌دهد.
- نسخه ۱۲.۵ محدودسازی منطقی سطح بالاتر را پوشش می‌دهد.
- نسخه ۶.۲ برنامه‌ریزهای `System.Reactive` برای جریان‌های رویداد را پوشش می‌دهد.
- نسخه ۷.۶ برنامه‌ریز آزمایشی `System.Reactive` را پوشش می‌دهد.


</div>


<div dir="rtl" align="right">


## ۱۳.۳ برنامه‌ریزی کد موازی

### مسئله

شما نیاز دارید که نحوه اجرای قطعات انفرادی کد در کد موازی را کنترل کنید.

### راه‌حل

پس از ایجاد یک نمونه `TaskScheduler` مناسب (به نسخه ۱۳.۲ مراجعه کنید)، می‌توانید آن را در گزینه‌هایی که به یک متد `Parallel` ارسال می‌کنید، بگنجانید. کد زیر یک دنباله از دنباله‌های ماتریس‌ها را دریافت می‌کند. این کد چندین حلقه موازی را شروع می‌کند و می‌خواهد همزمانی کل حلقه‌ها را صرف نظر از تعداد ماتریس‌ها در هر دنباله محدود کند:

</div>

```csharp
void RotateMatrices(IEnumerable<IEnumerable<Matrix>> collections, float degrees)
{
    var schedulerPair = new ConcurrentExclusiveSchedulerPair(
        TaskScheduler.Default, maxConcurrencyLevel: 8);
    TaskScheduler scheduler = schedulerPair.ConcurrentScheduler;
    ParallelOptions options = new ParallelOptions { TaskScheduler = scheduler };
    Parallel.ForEach(collections, options,
        matrices => Parallel.ForEach(matrices, options,
            matrix => matrix.Rotate(degrees)));
}
```

<div dir="rtl" align="right">


### بحث

`Parallel.Invoke` نیز یک نمونه از `ParallelOptions` را دریافت می‌کند، بنابراین می‌توانید یک `TaskScheduler` را به `Parallel.Invoke` به همان روش `Parallel.ForEach` ارسال کنید. اگر در حال انجام کد موازی پویا هستید، می‌توانید `TaskScheduler` را مستقیماً به `TaskFactory.StartNew` یا `Task.ContinueWith` ارسال کنید.

هیچ راهی برای ارسال `TaskScheduler` به کد `Parallel LINQ (PLINQ)` وجود ندارد.

### مراجعه کنید به

- نسخه ۱۳.۲ برنامه‌ریزهای وظیفه رایج و چگونگی انتخاب بین آن‌ها را پوشش می‌دهد.

## ۱۳.۴ همگام‌سازی جریان داده با استفاده از برنامه‌ریزها

### مسئله

شما نیاز دارید که نحوه اجرای قطعات انفرادی کد در کد جریان داده را کنترل کنید.

### راه‌حل

پس از ایجاد یک نمونه `TaskScheduler` مناسب (به نسخه ۱۳.۲ مراجعه کنید)، می‌توانید آن را در گزینه‌هایی که به یک بلوک جریان داده ارسال می‌کنید، بگنجانید. هنگامی که از رشته UI فراخوانی می‌شود، کد زیر یک شبکه جریان داده ایجاد می‌کند که همه مقادیر ورودی را در دو ضرب می‌کند (با استفاده از استخر رشته) و سپس مقادیر حاصل را به موارد یک جعبه لیست اضافه می‌کند (در رشته UI):

</div>

```csharp
var options = new ExecutionDataflowBlockOptions
{
    TaskScheduler = TaskScheduler.FromCurrentSynchronizationContext(),
};
var multiplyBlock = new TransformBlock<int, int>(item => item * 2);
var displayBlock = new ActionBlock<int>(
    result => ListBox.Items.Add(result), options);
multiplyBlock.LinkTo(displayBlock);
```

</div>

<div dir="rtl" align="right">


### بحث

مشخص کردن یک `TaskScheduler` به‌ویژه در هماهنگ کردن اقدامات بلوک‌ها در قسمت‌های مختلف شبکه جریان داده مفید است. برای مثال، می‌توانید از `ConcurrentExclusiveSchedulerPair.ExclusiveScheduler` استفاده کنید تا اطمینان حاصل کنید که بلوک‌های A و C هرگز کد را همزمان اجرا نمی‌کنند، در حالی که به بلوک B اجازه می‌دهید هر زمان که می‌خواهد اجرا شود.

به خاطر داشته باشید که همگام‌سازی توسط `TaskScheduler` فقط در حین اجرای کد اعمال می‌شود. برای مثال، اگر یک بلوک عملیاتی دارید که کد ناهمگام اجرا می‌کند و یک برنامه‌ریز انحصاری اعمال می‌کنید، کد در حالی که در انتظار است، در حال اجرا محسوب نمی‌شود.

می‌توانید یک `TaskScheduler` را برای هر نوع بلوک جریان داده مشخص کنید. حتی اگر یک بلوک کد شما را اجرا نکند (مثلاً `BufferBlock<T>`)، باز هم کارهای مدیریتی وجود دارد که باید انجام دهد و از `TaskScheduler` ارائه شده برای تمام کارهای داخلی خود استفاده خواهد کرد.

### مراجعه کنید به

- نسخه ۱۳.۲ برنامه‌ریزهای وظیفه رایج و چگونگی انتخاب بین آن‌ها را پوشش می‌دهد.


</div>