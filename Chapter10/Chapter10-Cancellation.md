
# فصل ۱۰. لغو کردن

فریم‌ورک .NET 4.0 پشتیبانی جامع و با طراحی خوبی برای لغو کردن (Cancellation) ارائه کرده است. این پشتیبانی به‌صورت همکارانه (cooperative) است، به این معنی که لغو شدن می‌تواند درخواست شود اما بر روی کد تحمیل (enforced) نمی‌شود. از آنجایی که لغو کردن همکارانه است، لغو کردن کد امکان‌پذیر نیست مگر اینکه برای پشتیبانی از لغو کردن نوشته شده باشد. به همین دلیل، توصیه می‌کنم تا حد امکان در کد خود از لغو کردن پشتیبانی کنید.

لغو کردن یک نوع سیگنال است، با دو جنبه متفاوت: منبعی که لغو کردن را آغاز می‌کند و گیرنده‌ای که به لغو کردن پاسخ می‌دهد. در .NET، منبع `CancellationTokenSource` و گیرنده `CancellationToken` است. دستورالعمل‌های این فصل هم منابع و هم گیرنده‌های لغو کردن را در کاربرد عادی پوشش می‌دهند و نحوه استفاده از پشتیبانی لغو کردن برای تعامل با اشکال غیر استاندارد لغو کردن را توضیح می‌دهند.

لغو کردن به عنوان نوع خاصی از خطا در نظر گرفته می‌شود. روال مرسوم این است که کد لغو شده یک استثنا از نوع `OperationCanceledException` (یا یک نوع مشتق شده مانند `TaskCanceledException`) پرتاب می‌کند. به این ترتیب کد فراخواننده می‌داند که لغو شدن مشاهده شده است.

برای نشان دادن به کد فراخواننده که متد شما از لغو کردن پشتیبانی می‌کند، باید یک `CancellationToken` را به عنوان پارامتر بگیرید. این پارامتر معمولاً آخرین پارامتر است، مگر اینکه متد شما پیشرفت را نیز گزارش کند (دستورالعمل ۲.۳). همچنین می‌توانید برای مصرف‌کنندگانی که نیازی به لغو کردن ندارند، یک اورلود (overload) یا مقدار پیش‌فرض پارامتر ارائه دهید:

```csharp
public void CancelableMethodWithOverload(CancellationToken cancellationToken)
{
    // کد در اینجا قرار می‌گیرد.
}

public void CancelableMethodWithOverload()
{
    CancelableMethodWithOverload(CancellationToken.None);
}

public void CancelableMethodWithDefault(
    CancellationToken cancellationToken = default)
{
    // کد در اینجا قرار می‌گیرد.
}
```

`CancellationToken.None` نشان‌دهنده یک توکن لغو است که هرگز لغو نخواهد شد و یک مقدار ویژه است که معادل `default(CancellationToken)` می‌باشد. مصرف‌کنندگان این مقدار را زمانی ارسال می‌کنند که نمی‌خواهند عملیات هرگز لغو شود.

جریان‌های ناهمزمان (Asynchronous streams) روشی مشابه اما پیچیده‌تر برای مدیریت لغو کردن دارند. لغو کردن جریان‌های ناهمزمان به تفصیل در دستورالعمل ۳.۴ پوشش داده شده است.

## ۱۰.۱ صادر کردن درخواست‌های لغو

**مسئله** کد شما، کدی قابل لغو (که یک `CancellationToken` می‌گیرد) را فراخوانی می‌کند و شما نیاز دارید آن را لغو کنید.

**راه حل** نوع `CancellationTokenSource` منبعی برای یک `CancellationToken` است. این تنها به کد امکان می‌دهد تا به درخواست‌های لغو پاسخ دهد؛ اعضای `CancellationTokenSource` به کد امکان می‌دهند درخواست لغو را صادر کنند.

هر `CancellationTokenSource` مستقل از دیگری است (مگر اینکه آنها را به هم پیوند دهید، همانطور که در دستورالعمل ۱۰.۸ بررسی شده است). خاصیت `Token` یک `CancellationToken` برای آن منبع را برمی‌گرداند و متد `Cancel` درخواست لغو واقعی را صادر می‌کند.

کد زیر ایجاد یک `CancellationTokenSource` و استفاده از `Token` و `Cancel` را نشان می‌دهد. این کد از یک متد `async` استفاده می‌کند زیرا نمایش آن در یک نمونه کد کوتاه آسان‌تر است؛ همان جفت `Token`/`Cancel` برای لغو کردن انواع کد استفاده می‌شود:

```csharp
void IssueCancelRequest()
{
    using var cts = new CancellationTokenSource();
    var task = CancelableMethodAsync(cts.Token);
    // در این مرحله، عملیات شروع شده است.
    // درخواست لغو را صادر کنید.
    cts.Cancel();
}
```

در کد مثال قبلی، متغیر `task` پس از شروع به کار نادیده گرفته می‌شود؛ در کد دنیای واقعی، آن `task` احتمالاً در جایی ذخیره می‌شود و `await` می‌شود تا کاربر نهایی از نتیجه نهایی آگاه باشد.

وقتی کد را لغو می‌کنید، تقریباً همیشه یک شرایط رقابتی (race condition) وجود دارد. ممکن است کد قابل لغو درست در آستانه اتمام باشد که درخواست لغو ارسال می‌شود، و اگر قبل از اتمام توکن لغو خود را بررسی نکند، در واقع با موفقیت کامل خواهد شد. در واقع، هنگامی که کد را لغو می‌کنید، سه احتمال وجود دارد: ممکن است به درخواست لغو پاسخ دهد (با پرتاب `OperationCanceledException`)، ممکن است با موفقیت به پایان برسد، یا ممکن است با خطایی بی‌ربط به لغو (پرتاب یک استثنای متفاوت) به پایان برسد.

کد زیر دقیقاً مانند کد قبلی است، با این تفاوت که `task` را `await` می‌کند و هر سه نتیجه ممکن را نشان می‌دهد:

```csharp
async Task IssueCancelRequestAsync()
{
    using var cts = new CancellationTokenSource();
    var task = CancelableMethodAsync(cts.Token);
    // در این مرحله، عملیات به خوبی در حال اجراست.
    // درخواست لغو را صادر کنید.
    cts.Cancel();
    // (به صورت ناهمزمان) منتظر بمانید تا عملیات به پایان برسد.
    try
    {
        await task;
        // اگر به اینجا رسیدیم، عملیات قبل از اعمال لغو با موفقیت کامل شد.
    }
    catch (OperationCanceledException)
    {
        // اگر به اینجا رسیدیم، عملیات قبل از اتمام لغو شد.
    }
    catch (Exception)
    {
        // اگر به اینجا رسیدیم، عملیات قبل از اعمال لغو با خطا کامل شد.
        throw;
    }
}
```

به طور معمول، راه‌اندازی `CancellationTokenSource` و صادر کردن لغو در متدهای جداگانه انجام می‌شود. هنگامی که یک نمونه `CancellationTokenSource` را لغو می‌کنید، آن به طور دائم لغو می‌شود. اگر به یک منبع دیگر نیاز دارید، باید یک نمونه دیگر ایجاد کنید. کد زیر یک مثال واقع‌بینانه‌تر مبتنی بر رابط کاربری گرافیکی (GUI) است که از یک دکمه برای شروع یک عملیات ناهمزمان و از دکمه دیگر برای لغو آن استفاده می‌کند. همچنین `StartButton` و `CancelButton` را غیرفعال و فعال می‌کند تا تنها یک عملیات در هر زمان وجود داشته باشد:

```csharp
private CancellationTokenSource _cts;

private async void StartButton_Click(object sender,
    RoutedEventArgs e)
{
    StartButton.IsEnabled = false;
    CancelButton.IsEnabled = true;
    try
    {
        _cts = new CancellationTokenSource();
        CancellationToken token = _cts.Token;
        await Task.Delay(TimeSpan.FromSeconds(5), token);
        MessageBox.Show("Delay completed successfully.");
    }
    catch (OperationCanceledException)
    {
        MessageBox.Show("Delay was canceled.");
    }
    catch (Exception)
    {
        MessageBox.Show("Delay completed with error.");
        throw;
    }
    finally
    {
        StartButton.IsEnabled = true;
        CancelButton.IsEnabled = false;
    }
}

private void CancelButton_Click(object sender, RoutedEventArgs
    e)
{
    _cts.Cancel();
    CancelButton.IsEnabled = false;
}
```

**بحث و بررسی** واقع‌بینانه‌ترین مثال در این دستورالعمل از یک برنامه GUI استفاده کرده است، اما این برداشت را نداشته باشید که لغو کردن فقط برای رابط‌های کاربری است. لغو کردن در سرور نیز جایگاه خود را دارد؛ به عنوان مثال، ASP.NET یک توکن لغو ارائه می‌دهد که نشان‌دهنده زمان‌بندی (timeout) درخواست یا قطع شدن ارتباط مشتری است. درست است که منابع توکن لغو در سمت سرور نادرتر هستند، اما دلیلی وجود ندارد که نتوانید از آنها استفاده کنید؛ آنها در صورتی که نیاز به لغو کردن به دلایلی که توسط لغو ASP.NET پوشش داده نمی‌شود، مانند یک زمان‌بندی اضافی برای بخشی از پردازش درخواست، مفید هستند.

**همچنین ببینید** دستورالعمل ۱۰.۴: ارسال توکن‌ها به کد async. دستورالالعمل ۱۰.۵: ارسال توکن‌ها به کد موازی. دستورالعمل ۱۰.۶: استفاده از توکن‌ها با کد واکنش‌گرا. دستورالعمل ۱۰.۷: ارسال توکن‌ها به شبکه‌های جریان داده.

## ۱۰.۲ پاسخ به درخواست‌های لغو با نظرسنجی (Polling)

**مسئله** در کد خود یک حلقه دارید که نیاز به پشتیبانی از لغو کردن دارد.

**راه حل** هنگامی که در کد خود یک حلقه پردازش دارید، API سطح پایین‌تری وجود ندارد که بتوانید `CancellationToken` را به آن ارسال کنید. در این حالت، باید به صورت دوره‌ای بررسی کنید که آیا توکن لغو شده است یا خیر. کد زیر به صورت دوره‌ای توکن را در حین اجرای یک حلقه CPU-bound مشاهده می‌کند:

```csharp
public int CancelableMethod(CancellationToken cancellationToken)
{
    for (int i = 0; i != 100; ++i)
    {
        Thread.Sleep(1000); // مقداری محاسبه در اینجا انجام می‌شود.
        cancellationToken.ThrowIfCancellationRequested();
    }
    return 42;
}
```

اگر حلقه شما بسیار فشرده باشد (یعنی اگر بدنه حلقه شما بسیار سریع اجرا شود)، ممکن است بخواهید تعداد دفعات بررسی توکن لغو خود را محدود کنید. مثل همیشه، قبل و بعد از چنین تغییری عملکرد خود را اندازه‌گیری کنید تا تصمیم بگیرید کدام روش بهتر است. کد زیر شبیه به مثال قبلی است، اما تکرارهای بیشتری از یک حلقه سریع‌تر دارد، بنابراین من یک محدودیت برای تعداد دفعات بررسی توکن اضافه کردم:

```csharp
public int CancelableMethod(CancellationToken cancellationToken)
{
    for (int i = 0; i != 100000; ++i)
    {
        Thread.Sleep(1); // مقداری محاسبه در اینجا انجام می‌شود.
        if (i % 1000 == 0)
            cancellationToken.ThrowIfCancellationRequested();
    }
    return 42;
}
```

محدودیت مناسب برای استفاده کاملاً به میزان کاری که انجام می‌دهید و میزان پاسخگویی لغو بستگی دارد.

**بحث و بررسی** اکثر اوقات، کد شما باید `CancellationToken` را به لایه بعدی ارسال کند. نمونه‌هایی از این در دستورالعمل‌های ۱۰.۴، ۱۰.۵، ۱۰.۶ و ۱۰.۷ وجود دارد. تکنیک نظرسنجی در این دستورالعمل تنها در صورتی باید استفاده شود که یک حلقه پردازشی دارید که نیاز به پشتیبانی از لغو کردن دارد.

عضو دیگری در `CancellationToken` به نام `IsCancellationRequested` وجود دارد که وقتی توکن لغو می‌شود، شروع به بازگرداندن `true` می‌کند. برخی افراد از این عضو برای پاسخ به لغو استفاده می‌کنند، معمولاً با برگرداندن یک مقدار پیش‌فرض یا `null`. من این رویکرد را برای اکثر کدها توصیه نمی‌کنم. الگوی استاندارد لغو، پرتاب یک `OperationCanceledException` است که توسط `ThrowIfCancellationRequested` مدیریت می‌شود. اگر کد بالاتر در پشته می‌خواهد استثنا را بگیرد و مانند این عمل کند که نتیجه `null` است، مشکلی نیست، اما هر کدی که `CancellationToken` را می‌گیرد باید از الگوی استاندارد لغو پیروی کند. اگر تصمیم گرفتید از الگوی لغو پیروی نکنید، حداقل آن را به وضوح مستند کنید.

`ThrowIfCancellationRequested` با نظرسنجی توکن لغو کار می‌کند؛ کد شما باید آن را در فواصل منظم فراخوانی کند. همچنین راهی برای ثبت یک فراخوان (callback) وجود دارد که هنگام درخواست لغو فراخوانی می‌شود. رویکرد فراخوان بیشتر در مورد تعامل با سایر سیستم‌های لغو است؛ دستورالعمل ۱۰.۹ استفاده از فراخوان‌ها با لغو را پوشش می‌دهد.

**همچنین ببینید** دستورالعمل ۱۰.۴: ارسال توکن‌ها به کد async. دستورالعمل ۱۰.۵: ارسال توکن‌ها به کد موازی. دستورالعمل ۱۰.۶: استفاده از توکن‌ها با کد واکنش‌گرا. دستورالعمل ۱۰.۷: ارسال توکن‌ها به شبکه‌های جریان داده. دستورالالعمل ۱۰.۹: استفاده از فراخوان‌ها به جای نظرسنجی برای پاسخ به درخواست‌های لغو. دستورالعمل ۱۰.۱: صادر کردن درخواست لغو.




## ۱۰.۳ لغو کردن به دلیل اتمام زمان (Timeouts)

**مسئله** شما کدی دارید که پس از یک زمان‌بندی نیاز به توقف اجرا دارد.

**راه حل** لغو کردن یک راه حل طبیعی برای موقعیت‌های زمان‌بندی (`timeout`) است. زمان‌بندی فقط یک نوع درخواست لغو است. کدی که نیاز به لغو شدن دارد، صرفاً توکن لغو را مانند هر لغو دیگری مشاهده می‌کند؛ نباید بداند و اهمیت بدهد که منبع لغو یک تایمر است.

برخی متدهای راحتی برای منابع توکن لغو وجود دارد که به طور خودکار بر اساس یک تایمر درخواست لغو را صادر می‌کنند. می‌توانید زمان‌بندی را به سازنده ارسال کنید:

```csharp
async Task IssueTimeoutAsync()
{
    using var cts = new
        CancellationTokenSource(TimeSpan.FromSeconds(5));
    CancellationToken token = cts.Token;
    await Task.Delay(TimeSpan.FromSeconds(10), token);
}
```

یا، اگر از قبل یک نمونه `CancellationTokenSource` دارید، می‌توانید یک زمان‌بندی برای آن نمونه شروع کنید:

```csharp
async Task IssueTimeoutAsync()
{
    using var cts = new CancellationTokenSource();
    CancellationToken token = cts.Token;
    cts.CancelAfter(TimeSpan.FromSeconds(5));
    await Task.Delay(TimeSpan.FromSeconds(10), token);
}
```

**بحث و بررسی** برای اجرای کد با یک زمان‌بندی، از `CancellationTokenSource` و `CancelAfter` (یا سازنده) استفاده کنید. راه‌های دیگری نیز برای انجام همین کار وجود دارد، اما استفاده از سیستم لغو موجود، آسان‌ترین و کارآمدترین گزینه است.

به خاطر داشته باشید که کد قابل لغو باید توکن لغو را مشاهده کند؛ لغو کردن کدی که قابلیت لغو ندارد، به راحتی امکان‌پذیر نیست.

**همچنین ببینید** دستورالعمل ۱۰.۴: ارسال توکن‌ها به کد async. دستورالعمل ۱۰.۵: ارسال توکن‌ها به کد موازی. دستورالعمل ۱۰.۶: استفاده از توکن‌ها با کد واکنش‌گرا. دستورالعمل ۱۰.۷: ارسال توکن‌ها به شبکه‌های جریان داده.

## ۱۰.۴ لغو کردن کدهای ناهمزمان (async)

**مسئله** شما از کدهای ناهمزمان استفاده می‌کنید و نیاز به پشتیبانی از لغو کردن دارید.

**راه حل** ساده‌ترین راه برای پشتیبانی از لغو کردن در کدهای ناهمزمان، صرفاً انتقال `CancellationToken` به لایه بعدی است. نمونه کد زیر یک تأخیر ناهمزمان را انجام می‌دهد و سپس مقداری را برمی‌گرداند؛ این کد با ارسال توکن به `Task.Delay` از لغو کردن پشتیبانی می‌کند:

```csharp
public async Task<int> CancelableMethodAsync(CancellationToken cancellationToken)
{
    await Task.Delay(TimeSpan.FromSeconds(2), cancellationToken);
    return 42;
}
```

بسیاری از APIهای ناهمزمان از `CancellationToken` پشتیبانی می‌کنند، بنابراین فعال کردن لغو برای خودتان معمولاً یک کار ساده است که شامل گرفتن یک توکن و ارسال آن است. به عنوان یک قانون کلی، اگر متد شما APIهایی را فراخوانی می‌کند که `CancellationToken` می‌گیرند، متد شما نیز باید یک `CancellationToken` بگیرد و آن را به هر API که از آن پشتیبانی می‌کند ارسال کند.

**بحث و بررسی** متأسفانه، برخی از متدها از لغو کردن پشتیبانی نمی‌کنند. وقتی در این وضعیت قرار می‌گیرید، راه حل آسانی وجود ندارد. توقف ایمن کد دلخواه امکان‌پذیر نیست مگر اینکه در یک فایل اجرایی جداگانه قرار گیرد. اگر کد شما، کدی را فراخوانی می‌کند که از لغو کردن پشتیبانی نمی‌کند، و اگر نمی‌خواهید آن کد را در یک فایل اجرایی جداگانه قرار دهید، همیشه می‌توانید با نادیده گرفتن نتیجه، وانمود به لغو عملیات کنید.

لغو کردن باید تا حد امکان به عنوان یک گزینه ارائه شود. این به این دلیل است که لغو مناسب در سطح بالاتر به لغو مناسب در سطح پایین‌تر بستگی دارد. بنابراین، هنگامی که متدهای ناهمزمان خود را می‌نویسید، تمام تلاش خود را برای گنجاندن پشتیبانی از لغو انجام دهید؛ هرگز نمی‌دانید کدام متد سطح بالاتر می‌خواهد متد شما را فراخوانی کند و ممکن است به لغو نیاز داشته باشد.

**همچنین ببینید** دستورالعمل ۱۰.۱: صادر کردن درخواست لغو. دستورالعمل ۱۰.۳: استفاده از لغو به عنوان زمان‌بندی (`timeout`).

## ۱۰.۵ لغو کردن کدهای موازی

**مسئله** شما از کدهای موازی استفاده می‌کنید و نیاز به پشتیبانی از لغو کردن دارید.

**راه حل** ساده‌ترین راه برای پشتیبانی از لغو کردن، ارسال `CancellationToken` به کد موازی است. متدهای موازی با گرفتن یک نمونه `ParallelOptions` از این پشتیبانی می‌کنند. می‌توانید `CancellationToken` را در یک نمونه `ParallelOptions` به روش زیر تنظیم کنید:

```csharp
void RotateMatrices(IEnumerable<Matrix> matrices, float degrees,
    CancellationToken token)
{
    Parallel.ForEach(matrices,
        new ParallelOptions { CancellationToken = token },
        matrix => matrix.Rotate(degrees));
}
```

یا، می‌توان `CancellationToken` را مستقیماً در بدنه حلقه مشاهده کرد:

```csharp
void RotateMatrices2(IEnumerable<Matrix> matrices, float degrees,
    CancellationToken token)
{
    // هشدار: توصیه نمی‌شود؛ به پایین مراجعه کنید.
    Parallel.ForEach(matrices, matrix =>
    {
        matrix.Rotate(degrees);
        token.ThrowIfCancellationRequested();
    });
}
```

روش جایگزین کار بیشتری می‌طلبد و به خوبی ترکیب نمی‌شود زیرا حلقه موازی، `OperationCanceledException` را در یک `AggregateException` قرار می‌دهد. همچنین، اگر `CancellationToken` را به عنوان بخشی از یک نمونه `ParallelOptions` ارسال کنید، کلاس `Parallel` ممکن است تصمیمات هوشمندانه‌تری در مورد تعداد دفعات بررسی توکن بگیرد. به همین دلایل، بهتر است توکن را به عنوان یک گزینه ارسال کنید. اگر توکن را به عنوان یک گزینه ارسال کنید، می‌توانید توکن را به بدنه حلقه نیز ارسال کنید، اما نمی‌خواهید توکن را فقط به بدنه حلقه ارسال کنید.

`Parallel LINQ (PLINQ)` نیز از لغو کردن داخلی با استفاده از عملگر `WithCancellation` پشتیبانی می‌کند:

```csharp
IEnumerable<int> MultiplyBy2(IEnumerable<int> values,
    CancellationToken cancellationToken)
{
    return values.AsParallel()
        .WithCancellation(cancellationToken)
        .Select(item => item * 2);
}
```

**بحث و بررسی** پشتیبانی از لغو کردن برای کارهای موازی برای تجربه کاربری خوب مهم است. اگر برنامه شما در حال انجام کار موازی باشد، حداقل برای مدت کوتاهی از مقدار زیادی CPU استفاده خواهد کرد. استفاده زیاد از CPU چیزی است که کاربران متوجه می‌شوند، حتی اگر با سایر برنامه‌های روی همان دستگاه تداخل نداشته باشد. بنابراین، توصیه می‌کنم هر زمان که محاسبات موازی (یا هر کار فشرده CPU دیگری) انجام می‌دهید، از لغو کردن پشتیبانی کنید، حتی اگر کل زمان صرف شده با استفاده بالای CPU بسیار طولانی نباشد.

**همچنین ببینید** دستورالعمل ۱۰.۱: صادر کردن درخواست لغو.




## ۱۰.۶ لغو کردن کدهای System.Reactive

**مسئله** شما کدی از `System.Reactive` دارید و نیاز دارید که قابل لغو باشد.

**راه حل** کتابخانه `System.Reactive` دارای مفهوم اشتراک (`subscription`) در یک جریان قابل مشاهده (`observable stream`) است. کد شما می‌تواند اشتراک را `dispose` کند تا از جریان لغو اشتراک کند. در بسیاری از موارد، این برای لغو منطقی جریان کافی است. به عنوان مثال، کد زیر به کلیک‌های ماوس زمانی که یک دکمه فشرده می‌شود اشتراک می‌یابد و زمانی که دکمه دیگری فشرده می‌شود لغو اشتراک می‌کند (اشتراک را لغو می‌کند):

```csharp
private IDisposable _mouseMovesSubscription;

private void StartButton_Click(object sender, RoutedEventArgs e)
{
    IObservable<Point> mouseMoves = Observable
        .FromEventPattern<MouseEventHandler, MouseEventArgs>(
            handler => (s, a) => handler(s, a),
            handler => MouseMove += handler,
            handler => MouseMove -= handler)
        .Select(x => x.EventArgs.GetPosition(this));
    _mouseMovesSubscription = mouseMoves.Subscribe(value =>
    {
        MousePositionLabel.Content = "(" + value.X + ", " + value.Y
            + ")";
    });
}

private void CancelButton_Click(object sender, RoutedEventArgs e)
{
    if (_mouseMovesSubscription != null)
        _mouseMovesSubscription.Dispose();
}
```

بسیار راحت است که `System.Reactive` با سیستم `CancellationTokenSource`/`CancellationToken` کار کند که هر چیز دیگری برای لغو استفاده می‌کند. بقیه این دستورالعمل، نحوه تعامل `observable`های `System.Reactive` با `CancellationToken` را پوشش می‌دهد.

اولین مورد استفاده اصلی زمانی است که کد `observable` در کد ناهمزمان پیچیده شده است. رویکرد اصلی در دستورالعمل ۸.۵ پوشش داده شد، و اکنون می‌خواهید پشتیبانی از `CancellationToken` را اضافه کنید. به طور کلی، ساده‌ترین راه برای انجام این کار، انجام تمام عملیات با استفاده از عملگرهای واکنش‌گرا و سپس فراخوانی `ToTask` برای تبدیل آخرین عنصر حاصل به یک `awaitable task` است. کد زیر نشان می‌دهد که چگونه آخرین عنصر را در یک دنباله به صورت ناهمزمان بگیرید:

```csharp
CancellationToken cancellationToken = ...
IObservable<int> observable = ...
int lastElement = await observable.TakeLast(1).ToTask(cancellationToken);
// یا: int lastElement = await observable.ToTask(cancellationToken);
```

گرفتن اولین عنصر بسیار مشابه است؛ فقط `observable` را قبل از فراخوانی `ToTask` تغییر دهید:

```csharp
CancellationToken cancellationToken = ...
IObservable<int> observable = ...
int firstElement = await observable.Take(1).ToTask(cancellationToken);
```

تبدیل ناهمزمان کل دنباله `observable` به یک `task` نیز مشابه است:

```csharp
CancellationToken cancellationToken = ...
IObservable<int> observable = ...
IList<int> allElements = await observable.ToList().ToTask(cancellationToken);
```

در نهایت، بیایید وضعیت معکوس را در نظر بگیریم. ما چندین راه برای مدیریت موقعیت‌هایی که کد `System.Reactive` به `CancellationToken` پاسخ می‌دهد، بررسی کرده‌ایم—یعنی جایی که یک درخواست لغو `CancellationTokenSource` به یک `disposal` آن اشتراک ترجمه می‌شود. همچنین می‌توان به روش دیگر نیز عمل کرد: صادر کردن یک درخواست لغو به عنوان پاسخی به `disposal`.

عملگرهای `FromAsync`، `StartAsync` و `SelectMany` همگی از لغو کردن پشتیبانی می‌کنند، همانطور که در دستورالعمل ۸.۶ دیده شد. این عملگرها اکثریت قریب به اتفاق موارد استفاده را پوشش می‌دهند. `Rx` همچنین یک نوع `CancellationDisposable` را فراهم می‌کند که هنگام `dispose` شدن، یک `CancellationToken` را لغو می‌کند. می‌توانید از `CancellationDisposable` مستقیماً به این صورت استفاده کنید:

```csharp
using (var cancellation = new CancellationDisposable())
{
    CancellationToken token = cancellation.Token;
    // توکن را به متدهایی که به آن پاسخ می‌دهند ارسال کنید.
}
// در این مرحله، توکن لغو شده است.
```

**بحث و بررسی** `System.Reactive (Rx)` مفهوم خاص خود را از لغو کردن دارد: `disposing` اشتراک‌ها. این دستورالعمل چندین راه را برای همکاری `Rx` با چارچوب لغو جهانی معرفی شده در .NET 4.0 بررسی کرد. تا زمانی که در بخش `Rx` کد خود هستید، از سیستم اشتراک/`disposal Rx` استفاده کنید؛ اگر فقط پشتیبانی از `CancellationToken` را در مرزها معرفی کنید، تمیزترین کار است.

**همچنین ببینید** دستورالعمل ۸.۵: بسته‌بندی‌های ناهمزمان در اطراف کد `Rx` (بدون پشتیبانی از لغو). دستورالعمل ۸.۶: بسته‌بندی‌های `Rx` در اطراف کد ناهمزمان (با پشتیبانی از لغو). دستورالالعمل ۱۰.۱: صادر کردن درخواست لغو.

## ۱۰.۷ لغو کردن شبکه‌های جریان داده (Dataflow Meshes)

**مسئله** شما از شبکه‌های جریان داده استفاده می‌کنید و نیاز به پشتیبانی از لغو کردن دارید.

**راه حل** بهترین راه برای پشتیبانی از لغو کردن در کد شما، ارسال `CancellationToken` به یک API قابل لغو است. هر بلوک در یک شبکه جریان داده از لغو کردن به عنوان بخشی از `DataflowBlockOptions` خود پشتیبانی می‌کند. اگر می‌خواهید بلوک جریان داده سفارشی خود را با پشتیبانی از لغو گسترش دهید، خاصیت `CancellationToken` را در گزینه‌های بلوک تنظیم کنید:

```csharp
IPropagatorBlock<int, int> CreateMyCustomBlock(
    CancellationToken cancellationToken)
{
    var blockOptions = new ExecutionDataflowBlockOptions
    {
        CancellationToken = cancellationToken
    };
    var multiplyBlock = new TransformBlock<int, int>(item => item * 2,
        blockOptions);
    var addBlock = new TransformBlock<int, int>(item => item + 2,
        blockOptions);
    var divideBlock = new TransformBlock<int, int>(item => item / 2,
        blockOptions);
    var flowCompletion = new DataflowLinkOptions
    {
        PropagateCompletion = true
    };
    multiplyBlock.LinkTo(addBlock, flowCompletion);
    addBlock.LinkTo(divideBlock, flowCompletion);
    return DataflowBlock.Encapsulate(multiplyBlock, divideBlock);
}
```

در این مثال، `CancellationToken` را برای هر بلوک در شبکه اعمال کردم که لزوماً ضروری نیست. از آنجایی که من همچنین تکمیل را در طول پیوندها انتشار می‌دهم، می‌توانستم آن را به بلوک اول اعمال کنم و اجازه دهم از طریق آن منتشر شود. لغو شدن به عنوان نوع خاصی از خطا در نظر گرفته می‌شود، بنابراین بلوک‌های پایین‌تر در خط لوله با خطا تکمیل می‌شوند زیرا آن خطا در حال انتشار است. با این حال، اگر در حال لغو یک شبکه هستم، می‌توانم هر بلوک را به طور همزمان لغو کنم، بنابراین در این مورد معمولاً گزینه `CancellationToken` را در هر بلوک تنظیم می‌کنم.

**بحث و بررسی** در شبکه‌های جریان داده، لغو کردن یک نوع پاکسازی (`flush`) نیست. وقتی یک بلوک لغو می‌شود، تمام ورودی‌های خود را کنار می‌گذارد و از گرفتن هر آیتم جدیدی خودداری می‌کند. بنابراین اگر یک بلوک را در حالی که در حال اجرا است لغو کنید، داده‌ها را از دست خواهید داد.

**همچنین ببینید** دستورالعمل ۱۰.۱: صادر کردن درخواست لغو.

## ۱۰.۸ تزریق درخواست‌های لغو

**مسئله** شما لایه‌ای از کد خود را دارید که نیاز است به درخواست‌های لغو پاسخ دهد و همچنین درخواست‌های لغو خود را به لایه بعدی صادر کند.

**راه حل** سیستم لغو .NET 4.0 از این سناریو به صورت داخلی پشتیبانی می‌کند که به آن توکن‌های لغو پیوندخورده (`linked cancellation tokens`) می‌گویند. یک منبع توکن لغو را می‌توان به یک (یا چند) توکن موجود پیوند زد. هنگامی که یک منبع توکن لغو پیوندخورده ایجاد می‌کنید، توکن حاصل در صورت لغو شدن هر یک از توکن‌های موجود یا لغو صریح منبع پیوندخورده، لغو می‌شود.

کد زیر یک درخواست `HTTP` ناهمزمان را انجام می‌دهد. توکن ارسال شده به متد `GetWithTimeoutAsync` نشان‌دهنده لغو درخواستی توسط کاربر نهایی است، و متد `GetWithTimeoutAsync` نیز یک زمان‌بندی (`timeout`) برای درخواست اعمال می‌کند:

```csharp
async Task<HttpResponseMessage> GetWithTimeoutAsync(HttpClient client,
    string url, CancellationToken cancellationToken)
{
    using CancellationTokenSource cts = CancellationTokenSource
        .CreateLinkedTokenSource(cancellationToken);
    cts.CancelAfter(TimeSpan.FromSeconds(2));
    CancellationToken combinedToken = cts.Token;
    return await client.GetAsync(url, combinedToken);
}
```

`combinedToken` حاصل، زمانی لغو می‌شود که یا کاربر `cancellationToken` موجود را لغو کند یا منبع پیوندخورده توسط `CancelAfter` لغو شود.

**بحث و بررسی** اگرچه مثال قبلی تنها از یک منبع `CancellationToken` استفاده کرد، متد `CreateLinkedTokenSource` می‌تواند هر تعداد `cancellationToken` را به عنوان پارامتر بگیرد. این به شما امکان می‌دهد یک توکن ترکیبی واحد ایجاد کنید که از آن می‌توانید لغو منطقی خود را پیاده‌سازی کنید. به عنوان مثال، `ASP.NET` یک توکن لغو ارائه می‌دهد که نشان‌دهنده قطع اتصال کاربر است (`HttpContext.RequestAborted`)؛ کد هندلر ممکن است یک توکن پیوندخورده ایجاد کند که هم به قطع اتصال کاربر و هم به دلیل لغو خود، مانند زمان‌بندی، پاسخ می‌دهد.

به طول عمر منبع توکن لغو پیوندخورده توجه داشته باشید. مثال قبلی مورد استفاده معمول است، که در آن یک یا چند `cancellationToken` به متد ارسال می‌شود، که سپس آنها را به هم پیوند می‌دهد و آنها را به عنوان یک توکن ترکیبی ارسال می‌کند. همچنین توجه داشته باشید که کد مثال از دستور `using` استفاده می‌کند، که تضمین می‌کند منبع توکن لغو پیوندخورده پس از اتمام عملیات (و زمانی که توکن ترکیبی دیگر استفاده نمی‌شود) `dispose` شود. در نظر بگیرید اگر کد دستور `using` را نداشت چه اتفاقی می‌افتاد: ممکن است متد `GetWithTimeoutAsync` چندین بار با همان توکن موجود (با عمر طولانی) فراخوانی شود، که در این صورت کد هر بار که متد فراخوانی می‌شود، یک منبع توکن جدید را پیوند می‌زند. حتی پس از اتمام درخواست‌های `HTTP` (و هیچ چیز از توکن ترکیبی استفاده نمی‌کند)، آن منبع پیوندخورده همچنان به توکن موجود متصل است. برای جلوگیری از نشت حافظه مانند این، منبع توکن لغو پیوندخورده را زمانی که دیگر به توکن ترکیبی نیاز ندارید، `dispose` کنید.

**همچنین ببینید** دستورالعمل ۱۰.۱: صادر کردن درخواست‌های لغو به طور کلی. دستورالعمل ۱۰.۳: استفاده از لغو به عنوان زمان‌بندی.

## ۱۰.۹ تعامل با سایر سیستم‌های لغو

**مسئله** شما کدی خارجی یا قدیمی دارید که مفهوم خاص خود را از لغو کردن دارد، و می‌خواهید آن را با استفاده از یک `CancellationToken` استاندارد کنترل کنید.

**راه حل** `CancellationToken` دو روش اصلی برای پاسخ به درخواست لغو دارد: نظرسنجی (`polling`) (پوشش داده شده در دستورالعمل ۱۰.۲) و فراخوان‌ها (`callbacks`) (موضوع این دستورالعمل). نظرسنجی معمولاً برای کدهای `CPU-bound`، مانند حلقه‌های پردازش داده، استفاده می‌شود؛ فراخوان‌ها معمولاً در تمام سناریوهای دیگر استفاده می‌شوند. می‌توانید با استفاده از متد `CancellationToken.Register` یک فراخوان برای یک توکن ثبت کنید.

به عنوان مثال، فرض کنید در حال بسته‌بندی نوع `System.Net.NetworkInformation.Ping` هستید و می‌خواهید بتوانید یک `ping` را لغو کنید. کلاس `Ping` قبلاً یک API مبتنی بر `Task` دارد اما از `CancellationToken` پشتیبانی نمی‌کند. در عوض، نوع `Ping` متد `SendAsyncCancel` خاص خود را دارد که می‌توانید از آن برای لغو یک `ping` استفاده کنید. برای انجام این کار، یک فراخوان را ثبت کنید که آن متد را فراخوانی می‌کند:

```csharp
async Task<PingReply> PingAsync(string hostNameOrAddress,
    CancellationToken cancellationToken)
{
    using var ping = new Ping();
    Task<PingReply> task = ping.SendPingAsync(hostNameOrAddress);
    using CancellationTokenRegistration _ = cancellationToken
        .Register(() => ping.SendAsyncCancel());
    return await task;
}
```

اکنون، هنگامی که یک لغو درخواست می‌شود، `CancellationToken` متد `SendAsyncCancel` را برای شما فراخوانی می‌کند و متد `SendPingAsync` را لغو می‌کند.

**بحث و بررسی** متد `CancellationToken.Register` را می‌توان برای تعامل با هر نوع سیستم لغو جایگزین استفاده کرد. اما به خاطر داشته باشید که وقتی یک متد یک `CancellationToken` را می‌گیرد، یک درخواست لغو فقط باید همان یک عملیات را لغو کند. برخی از سیستم‌های لغو جایگزین، لغو را با بستن برخی منابع پیاده‌سازی می‌کنند، که می‌تواند چندین عملیات را لغو کند؛ این نوع سیستم لغو به خوبی به یک `CancellationToken` نگاشت نمی‌شود. اگر تصمیم گرفتید این نوع لغو را در یک `CancellationToken` بسته‌بندی کنید، باید معناشناسی لغو غیرمعمول آن را مستند کنید.

به طول عمر ثبت فراخوان توجه داشته باشید. متد `Register` یک `disposable` را برمی‌گرداند که باید زمانی که دیگر نیازی به آن فراخوان نیست، `dispose` شود. کد مثال قبلی از دستور `using` برای پاکسازی زمانی که عملیات ناهمزمان کامل می‌شود، استفاده می‌کند. اگر کد آن دستور `using` را نداشت، هر بار که کد با همان `CancellationToken` (با عمر طولانی) فراخوانی می‌شود، یک فراخوان دیگر اضافه می‌کرد (که به نوبه خود شی `Ping` را زنده نگه می‌داشت). برای جلوگیری از نشت حافظه و منابع، ثبت فراخوان را زمانی که دیگر به فراخوان نیاز ندارید، `dispose` کنید.

**همچنین ببینید** دستورالعمل ۱۰.۲: پاسخ به یک توکن لغو با نظرسنجی به جای فراخوان‌ها. دستورالالعمل ۱۰.۱: صادر کردن درخواست‌های لغو به طور کلی.
