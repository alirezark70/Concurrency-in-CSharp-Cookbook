

<div dir="rtl">

# فصل ۵. مبانی Dataflow

کتابخانه **TPL Dataflow** یک کتابخانه قدرتمند دات‌نت است که به شما اجازه می‌دهد شبکه (mesh) یا خط لوله (pipeline) داده بسازید و داده‌هایتان را به‌شکل ناهمزمان (asynchronously) در آن جریان دهید.

**Dataflow** نوعی برنامه‌نویسی اعلانی (declarative) است: معمولاً کل شبکه را به‌طور کامل تعریف می‌کنید و سپس پردازش داده‌ها را آغاز می‌نمایید. این چارچوب شما را وادار می‌کند تا به ساختار برنامه خود به‌شکل متفاوتی بیندیشید، اما پس از طی این گام، برای سناریوهای زیادی بسیار طبیعی و مناسب خواهد بود.

هر شبکه از چندین بلاک تشکیل می‌شود که به هم متصل هستند. هر بلاک به‌تنهایی ساده است و صرفاً مسئول یک مرحله از پردازش داده می‌باشد. زمانی که بلاک روی داده کارش را انجام داد، نتیجه را به بلاک بعدی منتقل می‌کند.

> برای استفاده از TPL Dataflow، کافیست بسته‌ی NuGet به نام  
> `System.Threading.Tasks.Dataflow`  
> را به پروژه‌ی خود اضافه کنید.


---

## ۵.۱ اتصال بلاک‌ها

### مسئله

شما نیاز دارید بلاک‌های Dataflow را به هم وصل کنید تا یک شبکه بسازید.

### راه‌حل

بلاک‌های ارائه‌شده توسط TPL Dataflow صرفاً اعضای پایه‌ای را دارند. بسیاری از متدهای مفید به‌عنوان متد توسعه (extension methods) عرضه شدند.  
**متد توسعه LinkTo** یک راه راحت جهت اتصال بلاک‌هاست:

<div dir="ltr">

```csharp
var multiplyBlock = new TransformBlock<int, int>(item => item * 2);
var subtractBlock = new TransformBlock<int, int>(item => item - 2);

// پس از اتصال، مقادیری که از multiplyBlock خارج می‌شوند وارد subtractBlock می‌شوند.
multiplyBlock.LinkTo(subtractBlock);
```

</div>

> به صورت پیش‌فرض، اتصال بلاک‌ها فقط داده‌ها را انتقال می‌دهد و اطلاع از پایان کار (completion) یا خطاها را به‌هم منتقل نمی‌کند. اگر شبکه شما خطی باشد، احتمالاً مایل هستید پایان کار را نیز به بلاک بعدی انتقال دهید.

برای این منظور می‌توانید گزینه `PropagateCompletion` را در لینک فعال کنید:

<div dir="ltr">

```csharp
var multiplyBlock = new TransformBlock<int, int>(item => item * 2);
var subtractBlock = new TransformBlock<int, int>(item => item - 2);

var options = new DataflowLinkOptions { PropagateCompletion = true };
multiplyBlock.LinkTo(subtractBlock, options);

// ...
// پایان کار بلاک اول به صورت خودکار به بلاک دوم منتقل می‌شود.
multiplyBlock.Complete();
await subtractBlock.Completion;
```

</div>

---

### بحث و بررسی

پس از اتصال، داده به‌طور خودکار از بلاک منبع به بلاک مقصد جریان می‌یابد. گزینه `PropagateCompletion` بجز داده‌ها، پایان کار را نیز منتقل می‌نماید. در هر مرحله، اگر بلاک خطا دهد، خطا به بلاک بعدی منتقل می‌شود که معمولاً در قالب یک `AggregateException` ارسال می‌گردد.

در خط لوله‌ای طولانی که پایان کار منتقل می‌شود، خطای اصلی ممکن است بین چندین نمونه متداخل از `AggregateException` قرار گیرد. برای مدیریت این خطاها، کلاس `AggregateException` متدهایی مانند `Flatten` دارد که کمک‌کننده است.

امکان اتصال بلاک‌های Dataflow به روش‌های مختلف (انشعاب‌ها، اتصال‌ها و حتی حلقه‌ها) وجود دارد، اما خط لوله‌های خطی در اکثر موارد کافی هستند.  
ما روی همین خطوط لوله تمرکز می‌کنیم و به انشعاب‌ها نیز اشاره‌ی مختصری خواهیم داشت. سناریوهای بسیار پیشرفته‌تر خارج از محدوده این کتاب‌اند.

همچنین، نوع `DataflowLinkOptions` گزینه‌های متعددی (مثل `PropagateCompletion`) برای تنظیم لینک‌ها دارد و متد `LinkTo` می‌تواند آرگومان شرطی نیز بگیرد تا فقط داده‌های خاصی از لینک عبور کنند.  
اگر داده‌ای از شرط عبور نکند حذف نمی‌شود، بلکه تلاش می‌کند از لینک دیگری بگذرد و اگر لینکی نباشد، در بلاک می‌ماند. در این حالت، بلاک دیگر داده جدید تولید نمی‌کند تا داده گیر افتاده آزاد گردد.

---
<div dir="rtl">


## مراجع بیشتر

 **دستورالعمل ۵.۲**: نحوه انتقال خطا در لینک‌ها  
 **دستورالعمل ۵.۳**: حذف لینک بین بلاک‌ها  
 **دستورالعمل ۸.۸**: اتصال بلاک های Dataflow به System.Reactive

</div>


</div>



<div dir="rtl">

# ۵.۲ انتقال خطاها

## مسئله

شما باید راهکاری برای پاسخ به خطاهایی که ممکن است در شبکه‌ی داده‌ای (mesh) شما رخ دهد، داشته باشید.

---

## راه‌حل

اگر نماینده (delegate) که به یک بلاک داده‌ای دادید، استثنایی پرتاب کند، آن بلاک وارد حالت خطا (faulted state) می‌شود. در این حالت، بلاک تمام داده‌هایش را رها می‌کند و دیگر داده‌ی جدید قبول نخواهد کرد.

در نمونه زیر، بلاک هیچ خروجی تولید نمی‌کند. مقدار اول (`1`) یک استثنا ایجاد می‌کند و مقدار دوم (`2`) که ارسال شده بود، رها می‌شود:

<div dir="ltr">

```csharp
var block = new TransformBlock<int, int>(item =>
{
    if (item == 1)
        throw new InvalidOperationException("Blech.");
    return item * 2;
});
block.Post(1);
block.Post(2);
```

</div>

برای دریافت خطاهای یک بلاک داده‌ای، کافی است روی ویژگی `Completion` آن بلاک، عملیات `await` انجام دهید.  
این ویژگی یک `Task` برمی‌گرداند که با پایان کار بلاک (یا خطای آن) تکمیل می‌شود. اگر بلاک خطا داشته باشد، این `Task` هم Faulted می‌شود:

<div dir="ltr">

```csharp
try
{
    var block = new TransformBlock<int, int>(item =>
    {
        if (item == 1)
            throw new InvalidOperationException("Blech.");
        return item * 2;
    });
    block.Post(1);
    await block.Completion;
}
catch (InvalidOperationException)
{
    // استثنا در اینجا گرفته می‌شود.
}
```

</div>

زمانی که شما گزینه `PropagateCompletion` را هنگام اتصال بلاک‌ها استفاده می‌کنید، خطاها نیز همانند پایان کار منتقل می‌شوند. اما این خطاها به‌صورت تو در تو درون یک `AggregateException` به بلاک بعدی می‌رسند.

در مثال زیر، استثنا را از انتهای خط لوله دریافت می‌کنید. اگر استثنا از بلاک‌های بالادستی آمده باشد، خروجی به صورت `AggregateException` خواهد بود:

<div dir="ltr">

```csharp
try
{
    var multiplyBlock = new TransformBlock<int, int>(item =>
    {
        if (item == 1)
            throw new InvalidOperationException("Blech.");
        return item * 2;
    });
    var subtractBlock = new TransformBlock<int, int>(item => item - 2);
    multiplyBlock.LinkTo(subtractBlock, new DataflowLinkOptions { PropagateCompletion = true });
    multiplyBlock.Post(1);
    await subtractBlock.Completion;
}
catch (AggregateException)
{
    // استثنا در اینجا گرفته می‌شود.
}
```

</div>

هر بلاک خطاهای ورودی خود را حتی اگر از نوع `AggregateException` باشند، مجدداً داخل یک لایه جدید از همین نوع می‌پیچد.

اگر خطایی در ابتدای یک خط لوله طولانی رخ دهد و قبل از مشاهده از چندین لینک بگذرد، خطای اصلی در لایه‌های متعددی از `AggregateException` پیچیده می‌شود.  
متد `AggregateException.Flatten` برای ساده‌سازی مدیریت این خطاها کاربرد دارد.

---

## بحث و بررسی

هنگام طراحی شبکه یا خط لوله Dataflow، لازم است از ابتدا به مدیریت خطاها توجه داشته باشید.

در حالت‌های ساده، بهترین کار آن است که خطاها را تا انتهای خط لوله منتقل و همه را آنجا مدیریت کنید.  
در سناریوهای پیچیده‌تر، شاید بهتر باشد وضعیت هر بلاک را به‌محض پایان کار بررسی کنید.

اگر می‌خواهید که بلاک شما در مواجهه با استثناها زنده بماند، می‌توانید مدل کار خود را طوری تنظیم کنید که استثناها هم به‌عنوان نوعی داده تلقی شوند و اجازه دهید همراه با داده‌های سالم در شبکه حرکت کنند؛ بنابراین بلاک‌ها وارد حالت خطا نمی‌شوند و ادامه‌ی کار امکان‌پذیر است.  
برای اطلاعات بیشتر، به دستورالعمل ۱۴.۶ مراجعه نمایید.

---

## مراجع بیشتر

 [دستورالعمل ۵.۱](#فصل-۵-مبانی-dataflow) درباره اتصال بلاک‌ها

 [دستورالعمل ۵.۳] درباره شکستن لینک بین بلاک‌ها

 [دستورالعمل ۱۴.۶] درباره جریان استثناها همراه داده‌ها


</div>




<div dir="rtl">

# ۵.۳ قطع اتصال بلاک‌ها (Unlinking Blocks)

## مسئله

در برخی مواقع، ممکن است لازم باشد ساختار شبکه داده‌جریان (dataflow) خود را به صورت پویا تغییر دهید. این کار یک سناریوی پیشرفته است که به ندرت کاربرد دارد.

---

## راه‌حل

شما می‌توانید هر زمان که خواستید، بلاک‌های داده‌جریان را به هم وصل یا از هم جدا کنید. این اعمال کاملاً ایمن در برابر شرایط رقابتی (threadsafe) هستند.

وقتی بلاک‌ها را با `LinkTo` وصل می‌کنید، شیئی از نوع `IDisposable` دریافت می‌کنید. زمانی که می‌خواهید بلاک‌ها از هم جدا شوند، کافی است روی آن شیء متد `Dispose` را فراخوانی کنید:

<div dir="ltr">

```csharp
var multiplyBlock = new TransformBlock<int, int>(item => item * 2);
var subtractBlock = new TransformBlock<int, int>(item => item - 2);

IDisposable link = multiplyBlock.LinkTo(subtractBlock);
multiplyBlock.Post(1);
multiplyBlock.Post(2);

// قطع اتصال
link.Dispose();
```

</div>

در کدهای واقعی، استفاده از `using` ترجیح دارد تا مدیریت منابع به طور خودکار انجام شود.

---

### بحث و بررسی

تا زمانی که مطمئن نباشید لینک در وضعیت بیکار (idle) است، هنگام قطع ارتباط ممکن است شرایط رقابتی وجود داشته باشد. اما معمولاً این موضوع مشکلی ایجاد نمی‌کند؛ داده یا قبل قطع شدن منتقل می‌شود یا نه، اما هیچ اثری از دوبار ارسال یا از دست رفتن داده نخواهید داشت.

قطع اتصال بیشتر در سناریوهای خاص مفید است؛ مثلاً اگر بخواهید فیلتر یک لینک را تغییر دهید باید ابتدا لینک فعلی را حذف و سپس لینک جدید با شرط تازه بسازید. یا مثلاً برای متوقف‌کردن موقت بخشی از شبکه، می‌توانید یک لینک را در نقطه مناسب جدا کنید.

---

## مراجع بیشتر

 [دستورالعمل ۵.۱: ایجاد لینک بین بلاک‌ها](#اتصال-بلاکها-51)  


---

# ۵.۴ تنظیم سرعت (Throttling) بلاک‌ها

## مسئله

در یک سناریوی انشعاب (fork) نیاز دارید داده‌ها را بین شاخه‌ها به صورت متعادل (load-balancing) توزیع کنید.

---

## راه‌حل

زمانی که یک بلاک داده تولید می‌کند، خروجی خود را به ترتیب روی لینک‌هایش ارسال می‌کند و هر مقصد (target) به اندازه ظرفیت بافر خود داده دریافت خواهد کرد. چون هر بلاک به طور پیش‌فرض بافر نامحدود دارد، اولین مقصد همیشه تمام داده‌ها را جمع می‌کند و مقصد دوم خالی می‌ماند.

برای رفع این مشکل، باید ظرفیت (BoundedCapacity) بلاک مقصد را محدود کنید. مثلا با ظرفیت ۱:

<div dir="ltr">

```csharp
var sourceBlock = new BufferBlock<int>();
var options = new DataflowBlockOptions { BoundedCapacity = 1 };
var targetBlockA = new BufferBlock<int>(options);
var targetBlockB = new BufferBlock<int>(options);

sourceBlock.LinkTo(targetBlockA);
sourceBlock.LinkTo(targetBlockB);
```

</div>

---

### بحث و بررسی

تنظیم سرعت (Throttling) نه تنها برای تعادل بار در انشعاب‌ها مفید است، بلکه در شبکه‌هایی که مثلا داده‌ها از عملیات ورودی/خروجی تأمین می‌شوند نیز حیاتی است. محدود کردن ظرفیت سبب می‌شود فقط وقتی شبکه آماده است داده جدید دریافت شود.

---

## مراجع بیشتر

 [دستورالعمل ۵.۱: ایجاد لینک بین بلاک‌ها](#فصل-۵-مبانی-dataflow)


---

# ۵.۵ پردازش موازی با بلاک‌های داده‌جریان

## مسئله

می‌خواهید درون شبکه داده‌جریان خود، پردازش موازی انجام دهید.

---

## راه‌حل

هر بلاک داده‌جریان به طور پیش‌فرض مستقل عمل می‌کند؛ با این حال اگر بخواهید پردازش یک بلاک خاص به صورت موازی روی ورودی‌ها اجرا شود، باید گزینه `MaxDegreeOfParallelism` را افزایش دهید (مقدار پیش‌فرض یک است):

<div dir="ltr">

```csharp
var multiplyBlock = new TransformBlock<int, int>(
    item => item * 2,
    new ExecutionDataflowBlockOptions
    {
        MaxDegreeOfParallelism = DataflowBlockOptions.Unbounded
    });
var subtractBlock = new TransformBlock<int, int>(item => item - 2);

multiplyBlock.LinkTo(subtractBlock);
```

</div>

در مثال بالا هر تعداد تسک می‌توانند به طور همزمان مقدار ضرب را محاسبه کنند.

---

### بحث و بررسی

گزینه `MaxDegreeOfParallelism` موازی‌سازی داخلی بلاک را فعال می‌کند. اگر حجم داده‌های صف‌شده غیرمنتظره زیاد شد، به این معنی است که ممکن است شبکه به موازی‌سازی بیش‌تری نیاز داشته باشد.  
این گزینه برای بلاک‌هایی که عملیات ناهمزمان (مانند عملیات IO) انجام می‌دهند هم کاربرد دارد و تعداد جایگاه‌های همزمان پردازش را مشخص می‌کند.

---

## مراجع بیشتر

 [دستورالعمل ۵.۱: ارتباط بلاک‌ها با یکدیگر](#فصل-۵-مبانی-dataflow)


---

# ۵.۶ ساخت بلاک‌های سفارشی

## مسئله

در صورتی که منطق قابل استفاده مجددی دارید، می‌خواهید آن را در قالب یک بلاک داده‌جریان سفارشی بسته‌بندی کنید.

---

## راه‌حل

می‌توانید با متد `Encapsulate` قسمت‌هایی از شبکه که ورودی و خروجی دارند را به یک بلاک واحد تبدیل کنید. اینکار انتقال داده و پایان کار را بین دو نقطه کنترل می‌کند.

نمونه ساخت یک بلاک داده‌جریان سفارشی:

<div dir="ltr">

```csharp
IPropagatorBlock<int, int> CreateMyCustomBlock()
{
    var multiplyBlock = new TransformBlock<int, int>(item => item * 2);
    var addBlock = new TransformBlock<int, int>(item => item + 2);
    var divideBlock = new TransformBlock<int, int>(item => item / 2);

    var flowCompletion = new DataflowLinkOptions { PropagateCompletion = true };
    multiplyBlock.LinkTo(addBlock, flowCompletion);
    addBlock.LinkTo(divideBlock, flowCompletion);

    return DataflowBlock.Encapsulate(multiplyBlock, divideBlock);
}
```

</div>

---

### بحث و بررسی

هنگام کپسوله‌کردن یک شبکه به عنوان بلاک سفارشی، به گزینه‌هایی که می‌خواهید به کاربر ارائه کنید فکر کنید.  
در بسیاری از موارد، بلاک سفارشی باید تنظیمات خودش را داشته باشد و به جای پذیرش مستقیم DataflowBlockOptions، پارامترهای سفارشی دریافت کند.

نکته: متد `Encapsulate` فقط شبکه‌هایی با یک ورودی و یک خروجی را پوشش می‌دهد. برای ساخت بلاک سفارشی با چندین ورودی و خروجی می‌توانید یک شیء سفارشی با خواص مربوطه ایجاد کنید.  
در نهایت، پیاده‌سازی مستقیم رابط‌های داده‌جریان امکان‌پذیر است اما به مراتب دشوارتر خواهد بود.

---

## مراجع بیشتر

 [دستورالعمل ۵.۱: ایجاد لینک بین بلاک‌ها](#فصل-۵-مبانی-dataflow)

 [دستورالعمل ۵.۲: انتقال خطاها در لینک‌ها](#۵۲-انتقال-خطاها)

</div>
