
# فصل ۱۲. همگام‌سازی

هنگامی که برنامه شما از همزمانی استفاده می‌کند (همانطور که تقریباً تمام برنامه‌های .NET این کار را می‌کنند)، باید مراقب موقعیت‌هایی باشید که یک قطعه کد نیاز به به‌روزرسانی داده‌ها دارد در حالی که کد دیگری نیاز به دسترسی به همان داده‌ها دارد. هرگاه این اتفاق بیفتد، باید دسترسی به داده‌ها را همگام‌سازی کنید. دستورالعمل‌های این فصل متداول‌ترین انواع مورد استفاده برای همگام‌سازی دسترسی را پوشش می‌دهند. با این حال، اگر از سایر دستورالعمل‌های این کتاب به درستی استفاده کنید، متوجه خواهید شد که بسیاری از همگام‌سازی‌های متداول‌تر قبلاً توسط کتابخانه‌های مربوطه برای شما انجام شده است. قبل از پرداختن به دستورالعمل‌های همگام‌سازی، بیایید نگاهی دقیق‌تر به برخی موقعیت‌های متداول بیندازیم که در آنها همگام‌سازی ممکن است لازم باشد یا نباشد.

> **نکته**
> توضیحات همگام‌سازی در این بخش کمی ساده‌سازی شده‌اند، اما نتیجه‌گیری‌ها همگی صحیح هستند.

دو نوع اصلی همگام‌سازی وجود دارد: ارتباط و حفاظت از داده‌ها. ارتباط زمانی استفاده می‌شود که یک قطعه کد نیاز به اطلاع‌رسانی به قطعه کد دیگری از یک وضعیت خاص (به عنوان مثال، یک پیام جدید رسیده است) داشته باشد. من ارتباط را به طور کامل‌تر در دستورالعمل‌های این فصل پوشش خواهم داد؛ ادامه این مقدمه به بحث حفاظت از داده‌ها می‌پردازد.

شما باید از همگام‌سازی برای محافظت از داده‌های مشترک استفاده کنید زمانی که هر سه شرط زیر صحیح باشند:

   چندین قطعه کد به طور همزمان در حال اجرا هستند.

   این قطعات به همان داده‌ها دسترسی دارند (می‌خوانند یا می‌نویسند).

   حداقل یک قطعه کد در حال به‌روزرسانی (نوشتن) داده‌ها است.

دلیل شرط اول باید واضح باشد؛ اگر تمام کد شما از بالا به پایین اجرا شود و هرگز هیچ اتفاقی به طور همزمان رخ ندهد، هرگز نیازی به نگرانی در مورد همگام‌سازی ندارید. این مورد برای برخی از برنامه‌های Console ساده صادق است، اما اکثریت قریب به اتفاق برنامه‌های .NET از نوعی همزمانی استفاده می‌کنند. شرط دوم به این معنی است که اگر هر قطعه کد داده‌های محلی خاص خود را داشته باشد که به اشتراک نمی‌گذارد، نیازی به همگام‌سازی نیست؛ داده‌های محلی هرگز از هیچ قطعه کد دیگری قابل دسترسی نیستند. همچنین اگر داده‌های مشترک وجود داشته باشند اما هرگز تغییر نکنند، مانند زمانی که داده‌ها با استفاده از انواع تغییرناپذیر تعریف شده‌اند، نیازی به همگام‌سازی نیست. شرط سوم سناریوهایی مانند مقادیر پیکربندی و موارد مشابه را پوشش می‌دهد که در ابتدای برنامه تنظیم می‌شوند و سپس هرگز تغییر نمی‌کنند. اگر داده‌های مشترک فقط خوانده می‌شوند، نیازی به همگام‌سازی ندارند؛ فقط داده‌هایی که هم مشترک هستند و هم به‌روزرسانی می‌شوند، نیاز به همگام‌سازی دارند.

هدف از حفاظت از داده‌ها ارائه یک دیدگاه سازگار از داده‌ها به هر قطعه کد است. اگر یک قطعه کد در حال به‌روزرسانی داده‌ها است، می‌توانید از همگام‌سازی استفاده کنید تا آن به‌روزرسانی‌ها به صورت اتمیک برای بقیه سیستم ظاهر شوند.

یادگیری زمان نیاز به همگام‌سازی نیاز به تمرین دارد، بنابراین قبل از شروع دستورالعمل‌های این فصل، چند مثال را بررسی خواهیم کرد. به عنوان اولین مثال، کد زیر را در نظر بگیرید:

```csharp
async Task MyMethodAsync()
{
    int value = 10;
    await Task.Delay(TimeSpan.FromSeconds(1));
    value = value + 1;
    await Task.Delay(TimeSpan.FromSeconds(1));
    value = value - 1;
    await Task.Delay(TimeSpan.FromSeconds(1));
    Trace.WriteLine(value);
}
```

اگر متد `MyMethodAsync` از یک رشته threadpool فراخوانی شود (به عنوان مثال، از داخل `Task.Run`)، خطوط کد دسترسی به `value` ممکن است در رشته‌های threadpool جداگانه اجرا شوند. اما آیا به همگام‌سازی نیاز دارد؟ خیر، زیرا هیچ یک از آنها نمی‌توانند همزمان اجرا شوند. متد ناهمزمان است، اما ترتیبی نیز هست (به این معنی که هر بار یک قسمت پیشرفت می‌کند).

بسیار خب، بیایید مثال را کمی پیچیده‌تر کنیم. این بار کد ناهمزمان همزمان را اجرا خواهیم کرد:

```csharp
private int value;

async Task ModifyValueAsync()
{
    await Task.Delay(TimeSpan.FromSeconds(1));
    value = value + 1;
}

// هشدار: ممکن است نیاز به همگام‌سازی داشته باشد؛ به بحث زیر مراجعه کنید.
async Task<int> ModifyValueConcurrentlyAsync()
{
    // سه اصلاح همزمان را آغاز کنید.
    Task task1 = ModifyValueAsync();
    Task task2 = ModifyValueAsync();
    Task task3 = ModifyValueAsync();
    await Task.WhenAll(task1, task2, task3);
    return value;
}
```

این کد سه اصلاح را آغاز می‌کند که به طور همزمان اجرا می‌شوند. آیا به همگام‌سازی نیاز دارد؟ بستگی دارد. اگر می‌دانید که متد از یک GUI یا ASP.NET فراخوانی می‌شود (یا هر زمینه‌ای که فقط یک قطعه کد را در یک زمان اجازه می‌دهد)، همگام‌سازی ضروری نخواهد بود زیرا وقتی کد اصلاح واقعی داده اجرا می‌شود، در زمان دیگری نسبت به دو اصلاح داده دیگر اجرا می‌شود. به عنوان مثال، اگر کد قبلی در یک GUI اجرا شود، فقط یک رشته UI وجود دارد که هر یک از اصلاحات داده را اجرا می‌کند، بنابراین باید آنها را یکی یکی انجام دهد. بنابراین، اگر می‌دانید زمینه یک زمینه "یکی یکی" است، نیازی به همگام‌سازی نیست. با این حال، اگر همان متد از یک رشته threadpool فراخوانی شود (به عنوان مثال، از `Task.Run`)، همگام‌سازی ضروری خواهد بود. در این حالت، سه اصلاح داده می‌توانند در رشته‌های threadpool جداگانه اجرا شوند و `data.Value` را به طور همزمان به‌روزرسانی کنند، بنابراین باید دسترسی به `data.Value` را همگام‌سازی کنید.

اکنون بیایید یک پیچیدگی دیگر را در نظر بگیریم:

```csharp
private int value;

async Task ModifyValueAsync()
{
    int originalValue = value;
    await Task.Delay(TimeSpan.FromSeconds(1));
    value = originalValue + 1;
}
```

در نظر بگیرید چه اتفاقی می‌افتد اگر `ModifyValueAsync` چندین بار به طور همزمان فراخوانی شود. حتی اگر از یک زمینه "یکی یکی" فراخوانی شود، عضو داده بین هر فراخوانی از `ModifyValueAsync` به اشتراک گذاشته می‌شود، و `value` ممکن است هر زمان که آن متد یک `await` انجام دهد، تغییر کند. شما ممکن است بخواهید همگام‌سازی را حتی در یک زمینه "یکی یکی" اعمال کنید اگر می‌خواهید از این نوع اشتراک‌گذاری جلوگیری کنید. به عبارت دیگر، برای اینکه هر فراخوانی به `ModifyValueAsync` صبر کند تا تمام فراخوانی‌های قبلی کامل شوند، باید همگام‌سازی را اضافه کنید. این حتی اگر زمینه اطمینان حاصل کند که فقط یک رشته برای تمام کد استفاده می‌شود (یعنی رشته UI) نیز صحیح است. همگام‌سازی در این سناریو نوعی throttling برای متدهای ناهمزمان است (به دستورالعمل ۱۲.۲ مراجعه کنید).

بیایید یک مثال ناهمزمان دیگر را بررسی کنیم. می‌توانید از `Task.Run` برای انجام آنچه من "موازات‌سازی ساده" می‌نامم استفاده کنید - نوعی پردازش موازی اساسی که کارایی و قابلیت پیکربندی موازات‌سازی واقعی Parallel/PLINQ را ارائه نمی‌دهد. کد زیر یک مقدار مشترک را با استفاده از موازات‌سازی ساده به‌روزرسانی می‌کند:

```csharp
// کد بد!!
async Task<int> SimpleParallelismAsync()
{
    int value = 0;
    Task task1 = Task.Run(() => { value = value + 1; });
    Task task2 = Task.Run(() => { value = value + 1; });
    Task task3 = Task.Run(() => { value = value + 1; });
    await Task.WhenAll(task1, task2, task3);
    return value;
}
```

این کد سه تسک جداگانه را در thread pool (از طریق `Task.Run`) اجرا می‌کند، که همگی مقدار `value` را تغییر می‌دهند. بنابراین، شرایط همگام‌سازی ما اعمال می‌شود، و ما قطعاً در اینجا به همگام‌سازی نیاز داریم. توجه داشته باشید که حتی اگر `value` یک متغیر محلی باشد، به همگام‌سازی نیاز داریم؛ همچنان بین رشته‌ها به اشتراک گذاشته می‌شود، حتی اگر برای یک متد محلی باشد.

با حرکت به سمت کد موازی واقعی، بیایید مثالی را در نظر بگیریم که از نوع Parallel استفاده می‌کند:

```csharp
void IndependentParallelism(IEnumerable<int> values)
{
    Parallel.ForEach(values, item => Trace.WriteLine(item));
}
```

از آنجایی که این کد از `Parallel` استفاده می‌کند، باید فرض کنیم که بدنه حلقه موازی (`item => Trace.WriteLine(item)`) می‌تواند در چندین رشته اجرا شود. با این حال، بدنه حلقه فقط از داده‌های خودش می‌خواند؛ در اینجا هیچ اشتراک‌گذاری داده‌ای بین رشته‌ها وجود ندارد. کلاس `Parallel` داده‌ها را بین رشته‌ها تقسیم می‌کند به طوری که هیچ یک از آنها مجبور به اشتراک‌گذاری داده‌های خود نباشند. هر رشته‌ای که بدنه حلقه خود را اجرا می‌کند، مستقل از تمام رشته‌های دیگری است که همان بدنه حلقه را اجرا می‌کنند.





بنابراین، نیازی به همگام‌سازی کد قبلی نیست.

بیایید به مثالی از تجمیع مشابه آنچه در دستورالعمل ۴.۲ پوشش داده شد، نگاه کنیم:

```csharp
// کد بد!!
int ParallelSum(IEnumerable<int> values)
{
    int result = 0;
    Parallel.ForEach(source: values,
        localInit: () => 0,
        body: (item, state, localValue) => localValue + item,
        localFinally: localValue => { result += localValue; });
    return result;
}
```

در این مثال، کد دوباره از چندین رشته استفاده می‌کند؛ این بار، هر رشته با مقدار محلی خود که به ۰ مقداردهی اولیه شده است، شروع می‌شود (`() => 0`)، و برای هر مقدار ورودی که توسط آن رشته پردازش می‌شود، مقدار ورودی را به مقدار محلی خود اضافه می‌کند (`(item, state, localValue) => localValue + item`). در نهایت، تمام مقادیر محلی به مقدار بازگشتی اضافه می‌شوند (`localValue => { result += localValue; }`). دو مرحله اول مشکل‌ساز نیستند زیرا هیچ چیز بین رشته‌ها به اشتراک گذاشته نمی‌شود؛ مقادیر محلی و ورودی هر رشته مستقل از مقادیر محلی و ورودی سایر رشته‌ها هستند. با این حال، مرحله نهایی مشکل‌ساز است؛ هنگامی که مقدار محلی هر رشته به مقدار بازگشتی اضافه می‌شود، این وضعیتی است که در آن یک متغیر مشترک (`result`) وجود دارد که توسط چندین رشته قابل دسترسی است و توسط همه آنها به‌روزرسانی می‌شود. بنابراین، شما باید در مرحله نهایی از همگام‌سازی استفاده کنید (به دستورالعمل ۱۲.۱ مراجعه کنید).

کتابخانه‌های PLINQ، dataflow و reactive بسیار شبیه به مثال‌های Parallel هستند: تا زمانی که کد شما فقط با ورودی خود سروکار دارد، نیازی به نگرانی در مورد همگام‌سازی ندارد. من متوجه شده‌ام که اگر از این کتابخانه‌ها به درستی استفاده کنم، نیاز بسیار کمی به اضافه کردن همگام‌سازی به بیشتر کدهایم دارم.

در نهایت، بیایید در مورد مجموعه‌ها بحث کنیم. به یاد داشته باشید که سه شرطی که نیاز به همگام‌سازی دارند عبارتند از: چندین قطعه کد، داده‌های مشترک و به‌روزرسانی داده‌ها.

انواع تغییرناپذیر به طور طبیعی threadsafe هستند زیرا نمی‌توانند تغییر کنند؛ امکان به‌روزرسانی یک مجموعه تغییرناپذیر وجود ندارد، بنابراین نیازی به همگام‌سازی نیست. به عنوان مثال، کد زیر نیازی به همگام‌سازی ندارد زیرا وقتی هر رشته threadpool جداگانه یک مقدار را روی پشته قرار می‌دهد، یک پشته تغییرناپذیر جدید با آن مقدار ایجاد می‌کند و پشته اصلی را بدون تغییر باقی می‌گذارد:

```csharp
async Task<bool> PlayWithStackAsync()
{
    ImmutableStack<int> stack = ImmutableStack<int>.Empty;
    Task task1 = Task.Run(() =>
        Trace.WriteLine(stack.Push(3).Peek()));
    Task task2 = Task.Run(() =>
        Trace.WriteLine(stack.Push(5).Peek()));
    Task task3 = Task.Run(() =>
        Trace.WriteLine(stack.Push(7).Peek()));
    await Task.WhenAll(task1, task2, task3);
    return stack.IsEmpty; // همیشه true برمی‌گرداند.
}
```

هنگامی که کد شما از مجموعه‌های تغییرناپذیر استفاده می‌کند، معمول است که یک متغیر "ریشه" مشترک داشته باشید که خود آن تغییرناپذیر نیست. در این حالت، باید از همگام‌سازی استفاده کنید. در کد زیر، هر رشته یک مقدار را روی پشته قرار می‌دهد (ایجاد یک پشته تغییرناپذیر جدید) و سپس متغیر ریشه مشترک را به‌روزرسانی می‌کند؛ کد برای به‌روزرسانی متغیر پشته به همگام‌سازی نیاز دارد:

```csharp
// کد بد!!
async Task<bool> PlayWithStackAsync()
{
    ImmutableStack<int> stack = ImmutableStack<int>.Empty;
    Task task1 = Task.Run(() => { stack = stack.Push(3); });
    Task task2 = Task.Run(() => { stack = stack.Push(5); });
    Task task3 = Task.Run(() => { stack = stack.Push(7); });
    await Task.WhenAll(task1, task2, task3);
    return stack.IsEmpty;
}
```

مجموعه‌های threadsafe (مانند `ConcurrentDictionary`) کاملاً متفاوت هستند. برخلاف مجموعه‌های تغییرناپذیر، مجموعه‌های threadsafe را می‌توان به‌روزرسانی کرد. اما آنها تمام همگام‌سازی‌های مورد نیاز خود را به صورت داخلی دارند، بنابراین نیازی به نگرانی در مورد همگام‌سازی تغییرات مجموعه ندارید. اگر کد زیر به جای `ConcurrentDictionary`، یک `Dictionary` را به‌روزرسانی می‌کرد، نیاز به همگام‌سازی داشت؛ اما از آنجایی که یک `ConcurrentDictionary` را به‌روزرسانی می‌کند، نیازی به همگام‌سازی ندارد:

```csharp
async Task<int> ThreadsafeCollectionsAsync()
{
    var dictionary = new ConcurrentDictionary<int, int>();
    Task task1 = Task.Run(() => { dictionary.TryAdd(2, 3); });
    Task task2 = Task.Run(() => { dictionary.TryAdd(3, 5); });
    Task task3 = Task.Run(() => { dictionary.TryAdd(5, 7); });
    await Task.WhenAll(task1, task2, task3);
    return dictionary.Count; // همیشه 3 برمی‌گرداند.
}
```

### ۱۲.۱ قفل‌های مسدودکننده

**مشکل**

شما مقداری داده مشترک دارید و باید آن را به صورت ایمن از چندین رشته بخوانید و بنویسید.

**راه حل**

بهترین راه حل برای این وضعیت استفاده از عبارت `lock` است.

هنگامی که یک رشته وارد یک `lock` می‌شود، از ورود هر رشته دیگری به آن `lock` جلوگیری می‌کند تا زمانی که `lock` آزاد شود:

```csharp
class MyClass
{
    // این قفل از فیلد _value محافظت می‌کند.
    private readonly object _mutex = new object();
    private int _value;

    public void Increment()
    {
        lock (_mutex)
        {
            _value = _value + 1;
        }
    }
}
```

**بحث**

انواع دیگری از قفل‌ها در چارچوب .NET وجود دارد، مانند `Monitor`، `SpinLock` و `ReaderWriterLockSlim`. در اکثر برنامه‌ها، این انواع قفل تقریباً هرگز نباید مستقیماً استفاده شوند.

به ویژه، برای توسعه‌دهندگان طبیعی است که به `ReaderWriterLockSlim` روی بیاورند در حالی که نیازی به آن سطح از پیچیدگی نیست. عبارت پایه `lock` 99 درصد از موارد را به خوبی مدیریت می‌کند.

چهار دستورالعمل مهم در هنگام استفاده از قفل‌ها وجود دارد:

<div dir="rtl" align="right">


1.  دید قفل را محدود کنید.
2.  مستند کنید که قفل از چه چیزی محافظت می‌کند.
3.  کد زیر قفل را به حداقل برسانید.
4.  هرگز کد دلخواه را در حالی که قفل را نگه داشته‌اید، اجرا نکنید.

</div>

اولاً، باید سعی کنید دید قفل را محدود کنید. شیء مورد استفاده در عبارت `lock` باید یک فیلد خصوصی باشد و هرگز نباید در معرض هیچ متدی خارج از کلاس قرار گیرد. معمولاً حداکثر یک عضو قفل در هر نوع وجود دارد؛ اگر بیش از یک مورد دارید، بازآرایی آن نوع را به انواع جداگانه در نظر بگیرید. می‌توانید روی هر نوع مرجعی قفل کنید، اما من ترجیح می‌دهم یک فیلد مخصوص برای استفاده با عبارت `lock` داشته باشم، همانطور که در مثال آخر. اگر روی یک نمونه دیگر قفل می‌کنید، مطمئن شوید که خصوصی برای کلاس شما است؛ نباید به سازنده ارسال شده باشد یا از یک دریافت‌کننده ویژگی بازگردانده شده باشد. هرگز `lock(this)` یا `lock` را روی هیچ نمونه‌ای از `Type` یا `string` استفاده نکنید؛ این قفل‌ها می‌توانند باعث بن‌بست شوند زیرا از کدهای دیگر قابل دسترسی هستند.

ثانیاً، مستند کنید که قفل از چه چیزی محافظت می‌کند. این مرحله در ابتدا هنگام نوشتن کد به راحتی نادیده گرفته می‌شود، اما با افزایش پیچیدگی کد اهمیت بیشتری پیدا می‌کند.

ثالثاً، تمام تلاش خود را برای به حداقل رساندن کدی که در حالی که قفل را نگه داشته‌اید اجرا می‌شود، انجام دهید. یک نکته که باید به آن توجه کنید فراخوانی‌های مسدودکننده است؛ در حالت ایده‌آل، کد شما هرگز نباید در حالی که قفل را نگه داشته‌اید، مسدود شود.

در نهایت، هرگز کد دلخواه را زیر قفل فراخوانی نکنید. کد دلخواه می‌تواند شامل ایجاد رویدادها، فراخوانی متدهای مجازی یا فراخوانی نمایندگان باشد. اگر مجبور به اجرای کد دلخواه هستید، این کار را پس از آزاد شدن قفل انجام دهید.


<div dir="rtl" align="right">


**همچنین ببینید**

*   دستورالعمل ۱۲.۲ قفل‌های سازگار با async را پوشش می‌دهد. عبارت `lock` با `await` سازگار نیست.
*   دستورالعمل ۱۲.۳ سیگنال‌دهی بین رشته‌ها را پوشش می‌دهد. عبارت `lock` برای محافظت از داده‌های مشترک در نظر گرفته شده است، نه برای ارسال سیگنال بین رشته‌ها.
*   دستورالعمل ۱۲.۵ throttling را پوشش می‌دهد که تعمیمی از قفل کردن است. یک قفل را می‌توان به عنوان throttling به "یکی در یک زمان" تصور کرد.


</div>

### ۱۲.۲ قفل‌های Async

**مشکل**

شما مقداری داده مشترک دارید و نیاز دارید که آن را به صورت ایمن از چندین بلوک کد، که ممکن است از `await` استفاده کنند، بخوانید و بنویسید.

**راه حل**

نوع `SemaphoreSlim` در چارچوب .NET در .NET 4.5 برای سازگاری با async به‌روزرسانی شده است. در اینجا نحوه استفاده از آن آمده است:

```csharp
class MyClass
{
    // این قفل از فیلد _value محافظت می‌کند.
    private readonly SemaphoreSlim _mutex = new SemaphoreSlim(1);
    private int _value;

    public async Task DelayAndIncrementAsync()
    {
        await _mutex.WaitAsync();
        try
        {
            int oldValue = _value;
            await Task.Delay(TimeSpan.FromSeconds(oldValue));
            _value = oldValue + 1;
        }
        finally
        {
            _mutex.Release();
        }
    }
}
```

همچنین می‌توانید از نوع `AsyncLock` از کتابخانه Nito.AsyncEx استفاده کنید که API کمی ظریف‌تر دارد:

```csharp
class MyClass
{
    // این قفل از فیلد _value محافظت می‌کند.
    private readonly AsyncLock _mutex = new AsyncLock();
    private int _value;

    public async Task DelayAndIncrementAsync()
    {
        using (await _mutex.LockAsync())
        {
            int oldValue = _value;
            await Task.Delay(TimeSpan.FromSeconds(oldValue));
            _value = oldValue + 1;
        }
    }
}
```

<div dir="rtl" align="right">


**بحث**

همان دستورالعمل‌های دستورالعمل ۱۲.۱ در اینجا نیز اعمال می‌شود، به طور خاص:

1.  دید قفل را محدود کنید.
2.  مستند کنید که قفل از چه چیزی محافظت می‌کند.
3.  کد زیر قفل را به حداقل برسانید.
4.  هرگز کد دلخواه را در حالی که قفل را نگه داشته‌اید، اجرا نکنید.

نمونه‌های قفل خود را خصوصی نگه دارید؛ آنها را خارج از کلاس در معرض دید قرار ندهید. مطمئن شوید که دقیقاً آنچه یک نمونه قفل از آن محافظت می‌کند را به وضوح مستند (و با دقت در مورد آن فکر کنید). کدی که در حالی که قفل را نگه داشته‌اید اجرا می‌شود را به حداقل برسانید. به ویژه، کد دلخواه را فراخوانی نکنید؛ این شامل ایجاد رویدادها، فراخوانی متدهای مجازی و فراخوانی نمایندگان می‌شود.


> **نکته**
> نوع `AsyncLock` در بسته NuGet Nito.AsyncEx قرار دارد.

**همچنین ببینید**

*   دستورالعمل ۱۲.۴ سیگنال‌دهی سازگار با async را پوشش می‌دهد. قفل‌ها برای محافظت از داده‌های مشترک در نظر گرفته شده‌اند، نه برای عمل به عنوان سیگنال.


</div>



### ۱۲.۳ سیگنال‌های مسدودکننده

**مشکل**

شما باید از یک رشته به رشته دیگر اعلان ارسال کنید.

**راه حل**

متداول‌ترین و عمومی‌ترین سیگنال بین رشته‌ای `ManualResetEventSlim` است. یک رویداد بازنشانی دستی می‌تواند در یکی از دو حالت باشد: سیگنال‌دهی شده یا سیگنال‌دهی نشده. هر رشته‌ای می‌تواند رویداد را به حالت سیگنال‌دهی شده تنظیم کند یا رویداد را به حالت سیگنال‌دهی نشده بازنشانی کند. یک رشته همچنین می‌تواند منتظر بماند تا رویداد سیگنال‌دهی شود.

دو متد زیر توسط رشته‌های جداگانه فراخوانی می‌شوند؛ یک رشته منتظر سیگنال از دیگری می‌ماند:

```csharp
class MyClass
{
    private readonly ManualResetEventSlim _initialized =
        new ManualResetEventSlim();
    private int _value;

    public int WaitForInitialization()
    {
        _initialized.Wait();
        return _value;
    }

    public void InitializeFromAnotherThread()
    {
        _value = 13;
        _initialized.Set();
    }
}
```

<div dir="rtl" align="right">


**بحث**

`ManualResetEventSlim` یک سیگنال عمومی عالی از یک رشته به رشته دیگر است، اما شما فقط باید در صورت لزوم از آن استفاده کنید. اگر "سیگنال" در واقع پیامی است که مقداری داده را بین رشته‌ها ارسال می‌کند، پس استفاده از یک صف تولیدکننده/مصرف‌کننده را در نظر بگیرید. از طرف دیگر، اگر سیگنال‌ها فقط برای هماهنگی دسترسی به داده‌های مشترک استفاده می‌شوند، باید به جای آن از یک قفل استفاده کنید.

انواع دیگری از سیگنال‌های همگام‌سازی رشته در چارچوب .NET وجود دارد که کمتر مورد استفاده قرار می‌گیرند. اگر `ManualResetEventSlim` نیازهای شما را برآورده نمی‌کند، `AutoResetEvent`، `CountdownEvent` یا `Barrier` را در نظر بگیرید.

`ManualResetEventSlim` یک سیگنال همزمان است، بنابراین `WaitForInitialization` رشته فراخواننده را تا زمانی که سیگنال ارسال شود مسدود می‌کند. اگر می‌خواهید بدون مسدود کردن یک رشته منتظر سیگنال بمانید، پس یک سیگنال ناهمزمان می‌خواهید، همانطور که در دستورالعمل ۱۲.۴ توضیح داده شده است.

</div>

<div dir="rtl" align="right">


**همچنین ببینید**

*   دستورالعمل ۹.۶ صف‌های تولیدکننده/مصرف‌کننده مسدودکننده را پوشش می‌دهد.
*   دستورالعمل ۱۲.۱ قفل‌های مسدودکننده را پوشش می‌دهد.
*   دستورالعمل ۱۲.۴ سیگنال‌های سازگار با async را پوشش می‌دهد.

</div>

### ۱۲.۴ سیگنال‌های Async

**مشکل**

شما نیاز دارید که از یک قسمت از کد به قسمت دیگر اعلان ارسال کنید، و گیرنده اعلان باید به صورت ناهمزمان منتظر آن بماند.

**راه حل**

از `TaskCompletionSource<T>` برای ارسال اعلان به صورت ناهمزمان استفاده کنید، اگر اعلان فقط یک بار نیاز به ارسال دارد. کد ارسال‌کننده `TrySetResult` را فراخوانی می‌کند، و کد دریافت‌کننده منتظر ویژگی `Task` آن می‌ماند:

```csharp
class MyClass
{
    private readonly TaskCompletionSource<object> _initialized =
        new TaskCompletionSource<object>();
    private int _value1;
    private int _value2;

    public async Task<int> WaitForInitializationAsync()
    {
        await _initialized.Task;
        return _value1 + _value2;
    }

    public void Initialize()
    {
        _value1 = 13;
        _value2 = 17;
        _initialized.TrySetResult(null);
    }
}
```

نوع `TaskCompletionSource<T>` می‌تواند برای انتظار ناهمزمان برای هر نوع وضعیتی استفاده شود - در این حالت، یک اعلان از قسمت دیگر کد. این به خوبی کار می‌کند اگر سیگنال فقط یک بار ارسال شود، اما اگر نیاز به خاموش کردن سیگنال و همچنین روشن کردن آن داشته باشید، به خوبی کار نمی‌کند.

کتابخانه Nito.AsyncEx حاوی یک نوع `AsyncManualResetEvent` است که تقریباً معادل `ManualResetEvent` برای کد ناهمزمان است. مثال زیر ساختگی است، اما نحوه استفاده از نوع `AsyncManualResetEvent` را نشان می‌دهد:

```csharp
class MyClass
{
    private readonly AsyncManualResetEvent _connected =
        new AsyncManualResetEvent();

    public async Task WaitForConnectedAsync()
    {
        await _connected.WaitAsync();
    }

    public void ConnectedChanged(bool connected)
    {
        if (connected)
            _connected.Set();
        else
            _connected.Reset();
    }
}
```

**بحث**

سیگنال‌ها یک مکانیسم اعلان عمومی هستند. اما اگر آن "سیگنال" یک پیام باشد، که برای ارسال داده از یک قطعه کد به قطعه دیگر استفاده می‌شود، پس استفاده از یک صف تولیدکننده/مصرف‌کننده را در نظر بگیرید. به طور مشابه، از سیگنال‌های عمومی فقط برای هماهنگی دسترسی به داده‌های مشترک استفاده نکنید؛ در آن وضعیت، از یک قفل ناهمزمان استفاده کنید.

> **نکته**
> نوع `AsyncLock` در بسته NuGet Nito.AsyncEx قرار دارد.


<div dir="rtl" align="right">


**همچنین ببینید**

*   دستورالعمل ۹.۸ صف‌های تولیدکننده/مصرف‌کننده ناهمزمان را پوشش می‌دهد.
*   دستورالعمل ۱۲.۲ قفل‌های ناهمزمان را پوشش می‌دهد.
*   دستورالعمل ۱۲.۳ سیگنال‌های مسدودکننده را پوشش می‌دهد که می‌توانند برای اعلان‌ها بین رشته‌ها استفاده شوند.

<div>

### ۱۲.۵ Throttling

**مشکل**

شما کدی با همزمانی بسیار بالا دارید که در واقع بیش از حد همزمان است و نیاز به روشی برای کنترل همزمانی دارید.

کد زمانی بیش از حد همزمان است که قسمت‌هایی از برنامه قادر به همگام شدن با قسمت‌های دیگر نباشند و باعث انباشتگی آیتم‌های داده و مصرف حافظه شوند. در این سناریو، کنترل کردن قسمت‌هایی از کد می‌تواند از مشکلات حافظه جلوگیری کند.

**راه حل**

راه حل بسته به نوع همزمانی که کد شما انجام می‌دهد متفاوت است. این راه‌حل‌ها همگی همزمانی را به یک مقدار خاص محدود می‌کنند.

Reactive Extensions گزینه‌های قدرتمندتری مانند پنجره‌های زمانی کشویی دارد؛ کنترل کردن برای observables در System.Reactive به طور کامل‌تر در دستورالال ۶.۴ پوشش داده شده است.

کد dataflow و موازی همگی گزینه‌های داخلی برای کنترل همزمانی دارند:

<div dir="ltr" align="left">


```csharp

IPropagatorBlock<int, int> DataflowMultiplyBy2()
{
    var options = new ExecutionDataflowBlockOptions
    {
        MaxDegreeOfParallelism = 10
    };
    return new TransformBlock<int, int>(data => data * 2,
        options);
}

// استفاده از Parallel LINQ (PLINQ)
IEnumerable<int> ParallelMultiplyBy2(IEnumerable<int> values)
{
    return values.AsParallel()
        .WithDegreeOfParallelism(10)
        .Select(item => item * 2);
}

// استفاده از کلاس Parallel
void ParallelRotateMatrices(IEnumerable<Matrix> matrices, float
    degrees)
{
    var options = new ParallelOptions
    {
        MaxDegreeOfParallelism = 10
    };
    Parallel.ForEach(matrices, options, matrix =>
        matrix.Rotate(degrees));
}
```

</div>

<div dir="ltr" align="left">


کد ناهمزمان همزمان را می‌توان با استفاده از `SemaphoreSlim` کنترل کرد:

```csharp
async Task<string[]> DownloadUrlsAsync(HttpClient client,
    IEnumerable<string> urls)
{
    using var semaphore = new SemaphoreSlim(10);
    Task<string>[] tasks = urls.Select(async url =>
    {
        await semaphore.WaitAsync();
        try
        {
            return await client.GetStringAsync(url);
        }
        finally
        {
            semaphore.Release();
        }
    }).ToArray();
    return await Task.WhenAll(tasks);
}
```

</div>



**بحث**

کنترل کردن ممکن است زمانی لازم باشد که متوجه شوید کد شما از منابع زیادی (به عنوان مثال، CPU یا اتصالات شبکه) استفاده می‌کند. به خاطر داشته باشید که کاربران نهایی معمولاً ماشین‌هایی با قدرت کمتر از توسعه‌دهندگان دارند، بنابراین بهتر است کمی بیش از حد نیاز کنترل کنید تا اینکه کمتر از نیاز باشد.

**همچنین ببینید**

*   دستورالعمل ۶.۴ کنترل کردن برای کد واکنشی را پوشش می‌دهد.


</div>