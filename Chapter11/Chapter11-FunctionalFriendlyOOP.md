
<div dir="rtl" style="text-align:right;">

# فصل ۱۱. برنامه‌نویسی شی‌گرا با رویکرد کارا (Functional-Friendly OOP)

برنامه‌های مدرن نیازمند برنامه‌نویسی ناهمزمان هستند؛ این روزها سرورها باید بهتر از همیشه مقیاس‌پذیر باشند و برنامه‌های کاربردی سمت کاربر باید پاسخ‌گوتر از همیشه باشند. توسعه‌دهندگان می‌فهمند که باید برنامه‌نویسی ناهمزمان را بیاموزند و هنگامی که وارد این دنیای جدید می‌شوند، اغلب با برنامه‌نویسی شی‌گرا سنتی که به آن عادت دارند در تضاد قرار می‌گیرند.

علت اصلی این است که برنامه‌نویسی ناهمزمان ماهیتی فانکشنال دارد. منظورم از «فانکشنال» این نیست که «کار می‌کند»؛ بلکه یعنی سبک برنامه‌نویسی فانکشنال است به‌جای سبک رویه‌ای. بسیاری از توسعه‌دهندگان در دانشگاه اصول پایه‌ای برنامه‌نویسی فانکشنال را آموخته‌اند و از آن زمان به بعد چندان سراغش نرفته‌اند. اگر کدی مثل `(car (cdr '(3 5 7)))` شما را با یادآوری خاطرات سرکوب‌شده‌تان می‌ترساند، ممکن است در این دسته باشید. اما نگران نباشید؛ برنامه‌نویسی ناهمزمان مدرن پس از مدتی عادت کردن چندان سخت نیست.

پیشرفت اصلی در *async* این است که همچنان می‌توانید هنگام برنامه‌نویسی ناهمزمان به‌صورت رویه‌ای فکر کنید. این موضوع باعث می‌شود که نوشتن و درک متدهای ناهمزمان آسان‌تر شود. با این حال، در لایه‌های زیرین، کد ناهمزمان ذاتاً فانکشنال است و این وقتی باعث مشکل می‌شود که افراد بخواهند متدهای `async` را به طراحی‌های کلاسیک شی‌گرا تحمیل کنند. دستورالعمل‌های این فصل با همین نقاط برخورد و اصطکاک میان کد ناهمزمان و برنامه‌نویسی شی‌گرا سروکار دارند.

این نقاط اصطکاک به‌ویژه هنگام تبدیل یک پایگاه کد OOP موجود به یک پایگاه کد سازگار با *async* چشمگیر می‌شوند.

---

## ۱۱.۱ رابط‌ها و ارث‌بری ناهمزمان

### مسئله  
شما متدی در رابط یا کلاس پایه دارید که می‌خواهید آن را ناهمزمان کنید.

### راه‌حل  
کلید درک این مسئله و راه‌حل آن این است که بفهمید `async` یک جزئیات پیاده‌سازی است. کلیدواژه `async` تنها قابل اعمال روی متدهایی است که پیاده‌سازی دارند؛ امکان اعمال آن روی متدهای انتزاعی یا متدهای رابط وجود ندارد (مگر اینکه پیاده‌سازی پیش‌فرض داشته باشند). با این حال، می‌توانید متدی با همان امضا تعریف کنید که همان نوع بازگشتی یک متد `async` را داشته باشد، تنها بدون کلیدواژه `async`.

به یاد داشته باشید که *انواع* awaitable هستند، نه متدها. می‌توانید روی یک `Task` بازگشتی از متد `await` کنید، چه آن متد با `async` پیاده‌سازی شده باشد چه نباشد. بنابراین، یک متد رابط یا انتزاعی می‌تواند صرفاً یک `Task` (یا `Task<T>`) برگرداند و مقدار بازگشتی آن awaitable است.

کد زیر یک رابط با متدی ناهمزمان (بدون کلیدواژه `async`)، یک پیاده‌سازی از آن رابط (با `async`) و یک متد مستقل که متد رابط را مصرف می‌کند (از طریق `await`) نشان می‌دهد:

<div dir="ltr" align="left">


```csharp
public interface IMyAsyncInterface
{
    Task<int> CountBytesAsync(HttpClient client, string url);
}

public class MyAsyncClass : IMyAsyncInterface
{
    public async Task<int> CountBytesAsync(HttpClient client, string url)
    {
        var bytes = await client.GetByteArrayAsync(url);
        return bytes.Length;
    }
}

</div>

public async Task UseMyInterfaceAsync(HttpClient client, IMyAsyncInterface service)
{
    var result = await service.CountBytesAsync(client, "https://www.example.com");
    Trace.WriteLine(result);
}
```

همین الگو برای متدهای انتزاعی در کلاس‌های پایه نیز کار می‌کند.

امضای یک متد ناهمزمان تنها بدان معناست که پیاده‌سازی **ممکن است** ناهمزمان باشد. امکان دارد پیاده‌سازی واقعی به‌صورت همزمان باشد اگر کار ناهمزمان واقعی برای انجام دادن نداشته باشد. برای مثال، یک شبیه‌ساز تست ممکن است همان رابط را (بدون `async`) با چیزی مانند `FromResult` پیاده‌سازی کند:

<div dir="ltr" align="left">


```csharp
public class MyAsyncClassStub : IMyAsyncInterface
{
    public Task<int> CountBytesAsync(HttpClient client, string url)
    {
        return Task.FromResult(13); // مقادیر مجازی برای تست
    }
}
```
</div>

<div dir="rtl" style="text-align:right;">


### بحث  
در زمان نگارش این متن، `async` و `await` هنوز در حال گسترش کاربرد هستند. هرچه متدهای ناهمزمان رایج‌تر شوند، متدهای ناهمزمان در رابط‌ها و کلاس‌های پایه نیز شایع‌تر خواهند شد. کار با آن‌ها چندان دشوار نیست اگر در ذهن داشته باشید که نوع بازگشتی است که awaitable است (نه خود متد)، و این‌که تعریف یک متد ناهمزمان می‌تواند یا به‌صورت ناهمزمان یا همزمان پیاده‌سازی شود.


> **مشاهده کنید:**  
> [دستورالعمل 2.2](https://github.com/alirezark70/Concurrency-in-CSharp-Cookbook/blob/main/Chapter02/Chapter02-AsyncBasic.md#%DB%B2%DB%B2-%D8%A8%D8%A7%D8%B2%DA%AF%D8%B1%D8%AF%D8%A7%D9%86%D8%AF%D9%86-%D9%88%D8%B8%D8%A7%DB%8C%D9%81-%D8%AA%DA%A9%D9%85%DB%8C%D9%84%D8%B4%D8%AF%D9%87-completed-tasks) به بازگرداندن یک `Task` تکمیل‌شده می‌پردازد، یعنی پیاده‌سازی امضای یک متد ناهمزمان با کد همزمان.

</div>

</div>




## ۱۱.۲ ساخت ناهمزمان: کارخانه‌ها

### مسئله
شما یک نوع (type) می‌نویسید که نیاز دارد در سازنده‌اش کار ناهمزمانی انجام شود.

### راه‌حل
سازنده‌ها نمی‌توانند async باشند و نمی‌توانند از کلیدواژه await استفاده کنند. قطعاً مفید بود اگر می‌شد در یک سازنده await کرد، اما این تغییر بزرگی در زبان C# ایجاد می‌کرد.
یک امکان این است که یک سازنده داشته باشید و کنار آن متد مقداردهی اولیهٔ ناهمزمان (async initialization) قرار دهید، به‌طوری‌که نوع را بتوان به این شکل استفاده کرد:

<div dir="ltr" align="left">


```csharp
var instance = new MyAsyncClass();
await instance.InitializeAsync();
```

</div>

این رویکرد معایبی دارد. ممکن است فراموش کنید که InitializeAsync را فراخوانی کنید و نمونه بلافاصله پس از ساخته شدن قابل استفاده نیست.

راه‌حل بهتر این است که نوع خودش نقش کارخانه را برعهده بگیرد. نوع زیر الگوی متد کارخانهٔ ناهمزمان را نشان می‌دهد:

<div dir="ltr" align="left">


```csharp
class MyAsyncClass
{
    private MyAsyncClass()
    {
    }
    private async Task<MyAsyncClass> InitializeAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
        return this;
    }
    public static Task<MyAsyncClass> CreateAsync()
    {
        var result = new MyAsyncClass();
        return result.InitializeAsync();
    }
}
```

</div>

سازنده و متد InitializeAsync خصوصی هستند تا دیگر کدها نتوانند از آنها سوءاستفاده کنند؛ بنابراین تنها راه ایجاد یک نمونه از طریق متد ایستا CreateAsync است. کدی که این متد را فراخوانی می‌کند تا زمانی که مقداردهی اولیه کامل نشده باشد، به نمونه دسترسی ندارد.

سایر کدها می‌توانند نمونه را این‌گونه ایجاد کنند:

<div dir="ltr" align="left">


```csharp
MyAsyncClass instance = await MyAsyncClass.CreateAsync();
```
</div>

### بحث
مزیت اصلی این الگو این است که هیچ راهی برای دیگر کدها وجود ندارد که یک نمونهٔ مقداردهی‌نشده از MyAsyncClass دریافت کنند. به همین دلیل من هرگاه ممکن باشد این الگو را نسبت به روش‌های دیگر ترجیح می‌دهم.
متأسفانه این رویکرد در برخی سناریوها کار نمی‌کند — به‌ویژه وقتی که کد شما از یک ارائه‌دهندهٔ تزریق وابستگی (dependency injection) استفاده می‌کند. هیچ کتابخانهٔ بزرگ تزریق وابستگی یا وارونگی کنترل (inversion of control) با کد async به‌طور مستقیم کار نمی‌کند. اگر خود را در یکی از این سناریوها دیدید، چند جایگزین وجود دارد که می‌توانید در نظر بگیرید.
اگر نمونه‌ای که ایجاد می‌کنید در واقع یک منبع مشترک است، می‌توانید از نوع lazy ناهمزمان که در دستورالعمل 14.1 بحث شده استفاده کنید. در غیر این صورت، می‌توانید از الگوی مقداردهی اولیهٔ ناهمزمان که در دستورالعمل 11.3 آمده استفاده کنید.

در اینجا مثالی از کاری که نباید انجام دهید آورده شده است:

<div dir="ltr" align="left">


```csharp
class MyAsyncClass
{
    public MyAsyncClass()
    {
        InitializeAsync();
    }
    // BAD CODE!!
    private async void InitializeAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
    }
}
```

</div>

در نگاه اول، این روش منطقی به نظر می‌رسد: یک سازندهٔ معمولی دارید که یک عملیات ناهمزمان را آغاز می‌کند؛ اما چندین مشکل به‌خاطر استفاده از async void وجود دارد. مشکل اول این است که وقتی سازنده کامل می‌شود، نمونه هنوز به‌صورت ناهمزمان در حال مقداردهی اولیه است و راه واضحی برای تشخیص اینکه چه زمانی مقداردهی اولیهٔ ناهمزمان به پایان رسیده وجود ندارد. مشکل دوم مربوط به مدیریت خطا است: هر استثنایی که از InitializeAsync پرتاب شود، توسط هیچ catch‌ای که پیرامون ساختِ شی قرار دارد قابل گرفتن نیست.

### مشاهده کنید
دستورالعمل 11.3 الگوی مقداردهی اولیهٔ ناهمزمان را پوشش می‌دهد، روشی برای ساخت ناهمزمان که با تزریق وابستگی/وارونگی کنترل سازگار است.

دستورالعمل 14.1 مقداردهی lazy ناهمزمان را پوشش می‌دهد که راه‌حل مناسبی است اگر نمونه به‌صورت مفهومی یک منبع یا سرویس مشترک باشد.

</div>