
<div dir="rtl" style="text-align:right;">

# فصل ۱۱. برنامه‌نویسی شی‌گرا با رویکرد کارا (Functional-Friendly OOP)

برنامه‌های مدرن نیازمند برنامه‌نویسی ناهمزمان هستند؛ این روزها سرورها باید بهتر از همیشه مقیاس‌پذیر باشند و برنامه‌های کاربردی سمت کاربر باید پاسخ‌گوتر از همیشه باشند. توسعه‌دهندگان می‌فهمند که باید برنامه‌نویسی ناهمزمان را بیاموزند و هنگامی که وارد این دنیای جدید می‌شوند، اغلب با برنامه‌نویسی شی‌گرا سنتی که به آن عادت دارند در تضاد قرار می‌گیرند.

علت اصلی این است که برنامه‌نویسی ناهمزمان ماهیتی فانکشنال دارد. منظورم از «فانکشنال» این نیست که «کار می‌کند»؛ بلکه یعنی سبک برنامه‌نویسی فانکشنال است به‌جای سبک رویه‌ای. بسیاری از توسعه‌دهندگان در دانشگاه اصول پایه‌ای برنامه‌نویسی فانکشنال را آموخته‌اند و از آن زمان به بعد چندان سراغش نرفته‌اند. اگر کدی مثل `(car (cdr '(3 5 7)))` شما را با یادآوری خاطرات سرکوب‌شده‌تان می‌ترساند، ممکن است در این دسته باشید. اما نگران نباشید؛ برنامه‌نویسی ناهمزمان مدرن پس از مدتی عادت کردن چندان سخت نیست.

پیشرفت اصلی در *async* این است که همچنان می‌توانید هنگام برنامه‌نویسی ناهمزمان به‌صورت رویه‌ای فکر کنید. این موضوع باعث می‌شود که نوشتن و درک متدهای ناهمزمان آسان‌تر شود. با این حال، در لایه‌های زیرین، کد ناهمزمان ذاتاً فانکشنال است و این وقتی باعث مشکل می‌شود که افراد بخواهند متدهای `async` را به طراحی‌های کلاسیک شی‌گرا تحمیل کنند. دستورالعمل‌های این فصل با همین نقاط برخورد و اصطکاک میان کد ناهمزمان و برنامه‌نویسی شی‌گرا سروکار دارند.

این نقاط اصطکاک به‌ویژه هنگام تبدیل یک پایگاه کد OOP موجود به یک پایگاه کد سازگار با *async* چشمگیر می‌شوند.

---

## ۱۱.۱ رابط‌ها و ارث‌بری ناهمزمان

### مسئله  
شما متدی در رابط یا کلاس پایه دارید که می‌خواهید آن را ناهمزمان کنید.

### راه‌حل  
کلید درک این مسئله و راه‌حل آن این است که بفهمید `async` یک جزئیات پیاده‌سازی است. کلیدواژه `async` تنها قابل اعمال روی متدهایی است که پیاده‌سازی دارند؛ امکان اعمال آن روی متدهای انتزاعی یا متدهای رابط وجود ندارد (مگر اینکه پیاده‌سازی پیش‌فرض داشته باشند). با این حال، می‌توانید متدی با همان امضا تعریف کنید که همان نوع بازگشتی یک متد `async` را داشته باشد، تنها بدون کلیدواژه `async`.

به یاد داشته باشید که *انواع* awaitable هستند، نه متدها. می‌توانید روی یک `Task` بازگشتی از متد `await` کنید، چه آن متد با `async` پیاده‌سازی شده باشد چه نباشد. بنابراین، یک متد رابط یا انتزاعی می‌تواند صرفاً یک `Task` (یا `Task<T>`) برگرداند و مقدار بازگشتی آن awaitable است.

کد زیر یک رابط با متدی ناهمزمان (بدون کلیدواژه `async`)، یک پیاده‌سازی از آن رابط (با `async`) و یک متد مستقل که متد رابط را مصرف می‌کند (از طریق `await`) نشان می‌دهد:

<div dir="ltr" align="left">


```csharp
public interface IMyAsyncInterface
{
    Task<int> CountBytesAsync(HttpClient client, string url);
}

public class MyAsyncClass : IMyAsyncInterface
{
    public async Task<int> CountBytesAsync(HttpClient client, string url)
    {
        var bytes = await client.GetByteArrayAsync(url);
        return bytes.Length;
    }
}

</div>

public async Task UseMyInterfaceAsync(HttpClient client, IMyAsyncInterface service)
{
    var result = await service.CountBytesAsync(client, "https://www.example.com");
    Trace.WriteLine(result);
}
```

همین الگو برای متدهای انتزاعی در کلاس‌های پایه نیز کار می‌کند.

امضای یک متد ناهمزمان تنها بدان معناست که پیاده‌سازی **ممکن است** ناهمزمان باشد. امکان دارد پیاده‌سازی واقعی به‌صورت همزمان باشد اگر کار ناهمزمان واقعی برای انجام دادن نداشته باشد. برای مثال، یک شبیه‌ساز تست ممکن است همان رابط را (بدون `async`) با چیزی مانند `FromResult` پیاده‌سازی کند:

<div dir="ltr" align="left">


```csharp
public class MyAsyncClassStub : IMyAsyncInterface
{
    public Task<int> CountBytesAsync(HttpClient client, string url)
    {
        return Task.FromResult(13); // مقادیر مجازی برای تست
    }
}
```
</div>

<div dir="rtl" style="text-align:right;">


### بحث  
در زمان نگارش این متن، `async` و `await` هنوز در حال گسترش کاربرد هستند. هرچه متدهای ناهمزمان رایج‌تر شوند، متدهای ناهمزمان در رابط‌ها و کلاس‌های پایه نیز شایع‌تر خواهند شد. کار با آن‌ها چندان دشوار نیست اگر در ذهن داشته باشید که نوع بازگشتی است که awaitable است (نه خود متد)، و این‌که تعریف یک متد ناهمزمان می‌تواند یا به‌صورت ناهمزمان یا همزمان پیاده‌سازی شود.


> **مشاهده کنید:**  
> [دستورالعمل 2.2](https://github.com/alirezark70/Concurrency-in-CSharp-Cookbook/blob/main/Chapter02/Chapter02-AsyncBasic.md#%DB%B2%DB%B2-%D8%A8%D8%A7%D8%B2%DA%AF%D8%B1%D8%AF%D8%A7%D9%86%D8%AF%D9%86-%D9%88%D8%B8%D8%A7%DB%8C%D9%81-%D8%AA%DA%A9%D9%85%DB%8C%D9%84%D8%B4%D8%AF%D9%87-completed-tasks) به بازگرداندن یک `Task` تکمیل‌شده می‌پردازد، یعنی پیاده‌سازی امضای یک متد ناهمزمان با کد همزمان.

</div>

</div>




## ۱۱.۲ ساخت ناهمزمان: کارخانه‌ها

### مسئله
شما یک نوع (type) می‌نویسید که نیاز دارد در سازنده‌اش کار ناهمزمانی انجام شود.

### راه‌حل
سازنده‌ها نمی‌توانند async باشند و نمی‌توانند از کلیدواژه await استفاده کنند. قطعاً مفید بود اگر می‌شد در یک سازنده await کرد، اما این تغییر بزرگی در زبان C# ایجاد می‌کرد.
یک امکان این است که یک سازنده داشته باشید و کنار آن متد مقداردهی اولیهٔ ناهمزمان (async initialization) قرار دهید، به‌طوری‌که نوع را بتوان به این شکل استفاده کرد:

<div dir="ltr" align="left">


```csharp
var instance = new MyAsyncClass();
await instance.InitializeAsync();
```

</div>

این رویکرد معایبی دارد. ممکن است فراموش کنید که InitializeAsync را فراخوانی کنید و نمونه بلافاصله پس از ساخته شدن قابل استفاده نیست.

راه‌حل بهتر این است که نوع خودش نقش کارخانه را برعهده بگیرد. نوع زیر الگوی متد کارخانهٔ ناهمزمان را نشان می‌دهد:

<div dir="ltr" align="left">


```csharp
class MyAsyncClass
{
    private MyAsyncClass()
    {
    }
    private async Task<MyAsyncClass> InitializeAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
        return this;
    }
    public static Task<MyAsyncClass> CreateAsync()
    {
        var result = new MyAsyncClass();
        return result.InitializeAsync();
    }
}
```

</div>

سازنده و متد InitializeAsync خصوصی هستند تا دیگر کدها نتوانند از آنها سوءاستفاده کنند؛ بنابراین تنها راه ایجاد یک نمونه از طریق متد ایستا CreateAsync است. کدی که این متد را فراخوانی می‌کند تا زمانی که مقداردهی اولیه کامل نشده باشد، به نمونه دسترسی ندارد.

سایر کدها می‌توانند نمونه را این‌گونه ایجاد کنند:

<div dir="ltr" align="left">


```csharp
MyAsyncClass instance = await MyAsyncClass.CreateAsync();
```
</div>

### بحث
مزیت اصلی این الگو این است که هیچ راهی برای دیگر کدها وجود ندارد که یک نمونهٔ مقداردهی‌نشده از MyAsyncClass دریافت کنند. به همین دلیل من هرگاه ممکن باشد این الگو را نسبت به روش‌های دیگر ترجیح می‌دهم.
متأسفانه این رویکرد در برخی سناریوها کار نمی‌کند — به‌ویژه وقتی که کد شما از یک ارائه‌دهندهٔ تزریق وابستگی (dependency injection) استفاده می‌کند. هیچ کتابخانهٔ بزرگ تزریق وابستگی یا وارونگی کنترل (inversion of control) با کد async به‌طور مستقیم کار نمی‌کند. اگر خود را در یکی از این سناریوها دیدید، چند جایگزین وجود دارد که می‌توانید در نظر بگیرید.
اگر نمونه‌ای که ایجاد می‌کنید در واقع یک منبع مشترک است، می‌توانید از نوع lazy ناهمزمان که در دستورالعمل 14.1 بحث شده استفاده کنید. در غیر این صورت، می‌توانید از الگوی مقداردهی اولیهٔ ناهمزمان که در دستورالعمل 11.3 آمده استفاده کنید.

در اینجا مثالی از کاری که نباید انجام دهید آورده شده است:

<div dir="ltr" align="left">


```csharp
class MyAsyncClass
{
    public MyAsyncClass()
    {
        InitializeAsync();
    }
    // BAD CODE!!
    private async void InitializeAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
    }
}
```

</div>

در نگاه اول، این روش منطقی به نظر می‌رسد: یک سازندهٔ معمولی دارید که یک عملیات ناهمزمان را آغاز می‌کند؛ اما چندین مشکل به‌خاطر استفاده از async void وجود دارد. مشکل اول این است که وقتی سازنده کامل می‌شود، نمونه هنوز به‌صورت ناهمزمان در حال مقداردهی اولیه است و راه واضحی برای تشخیص اینکه چه زمانی مقداردهی اولیهٔ ناهمزمان به پایان رسیده وجود ندارد. مشکل دوم مربوط به مدیریت خطا است: هر استثنایی که از InitializeAsync پرتاب شود، توسط هیچ catch‌ای که پیرامون ساختِ شی قرار دارد قابل گرفتن نیست.

### مشاهده کنید
دستورالعمل 11.3 الگوی مقداردهی اولیهٔ ناهمزمان را پوشش می‌دهد، روشی برای ساخت ناهمزمان که با تزریق وابستگی/وارونگی کنترل سازگار است.

دستورالعمل 14.1 مقداردهی lazy ناهمزمان را پوشش می‌دهد که راه‌حل مناسبی است اگر نمونه به‌صورت مفهومی یک منبع یا سرویس مشترک باشد.




## ۱۱.۳ ساخت ناهمزمان: الگوی مقداردهی اولیهٔ ناهمزمان

### مسئله
شما نوعی می‌نویسید که نیاز دارد در سازنده‌اش کار ناهمزمانی انجام شود، اما نمی‌توانید از الگوی کارخانهٔ ناهمزمان (دستورالعمل 11.2) استفاده کنید چون نمونه از طریق بازتاب (reflection) ایجاد می‌شود (مثلاً یک کتابخانهٔ تزریق وابستگی/وارونگی کنترل، data binding، Activator.CreateInstance و غیره).

### راه‌حل
وقتی با این سناریو روبه‌رو می‌شوید، ناچارید یک نمونهٔ مقداردهی‌نشده برگردانید، اما می‌توانید این وضعیت را با به‌کارگیری یک الگوی رایج کاهش دهید: الگوی مقداردهی اولیهٔ ناهمزمان.

هر نوعی که نیاز به مقداردهی اولیهٔ ناهمزمان دارد باید یک خصوصیت (property) مانند زیر تعریف کند:


<div dir="ltr" align="left">


```csharp
Task Initialization { get; }


```

</div>


معمولاً این را در یک رابطِ نشانگر (marker interface) برای انواعی که نیاز به مقداردهی اولیهٔ ناهمزمان دارند تعریف می‌کنم:

<div dir="ltr" align="left">


```csharp
/// <summary>
/// Marks a type as requiring asynchronous initialization
/// and provides the result of that initialization.
/// </summary>
public interface IAsyncInitialization
{
    /// <summary>
    /// The result of the asynchronous initialization of this
    instance.
    /// </summary>
    Task Initialization { get; }
}
```

</div>

وقتی این الگو را پیاده‌سازی می‌کنید، باید مقداردهی اولیه را در سازنده آغاز کنید (و خصوصیت Initialization را مقداردهی کنید). نتایج مقداردهی اولیهٔ ناهمزمان (شامل هر استثنایی) از طریق آن خصوصیت Initialization در دسترس قرار می‌گیرند. در اینجا یک پیاده‌سازی نمونه از یک نوع ساده که از مقداردهی اولیهٔ ناهمزمان استفاده می‌کند آورده شده است:

<div dir="ltr" align="left">


```csharp
class MyFundamentalType : IMyFundamentalType,
    IAsyncInitialization
{
    public MyFundamentalType()
    {
        Initialization = InitializeAsync();
    }
    public Task Initialization { get; private set; }
    private async Task InitializeAsync()
    {
        // Asynchronously initialize this instance.
        await Task.Delay(TimeSpan.FromSeconds(1));
    }
}
```

</div>

اگر از یک کتابخانهٔ تزریق وابستگی/وارونگی کنترل استفاده می‌کنید، می‌توانید یک نمونه از این نوع را به‌صورت زیر ایجاد و مقداردهی اولیه کنید:

<div dir="ltr" align="left">


```csharp
IMyFundamentalType instance =
    UltimateDIFactory.Create<IMyFundamentalType>();
var instanceAsyncInit = instance as IAsyncInitialization;
if (instanceAsyncInit != null)
    await instanceAsyncInit.Initialization;

```

</div>

شما می‌توانید این الگو را برای ترکیب (composition) انواعی با مقداردهی اولیهٔ ناهمزمان گسترش دهید. در مثال زیر نوع دیگری که به یک IMyFundamentalType وابسته است تعریف شده:

<div dir="ltr" align="left">


```csharp
class MyComposedType : IMyComposedType, IAsyncInitialization
{
    private readonly IMyFundamentalType _fundamental;
    public MyComposedType(IMyFundamentalType fundamental)
    {
        _fundamental = fundamental;
        Initialization = InitializeAsync();
    }
    public Task Initialization { get; private set; }
    private async Task InitializeAsync()
    {
        // Asynchronously wait for the fundamental instance to
        initialize,
        // if necessary.
        var fundamentalAsyncInit = _fundamental as
            IAsyncInitialization;
        if (fundamentalAsyncInit != null)
            await fundamentalAsyncInit.Initialization;
        // Do our own initialization (synchronous or asynchronous).
        ...
    }
}
```

</div>

نوع ترکیبی قبل از ادامهٔ مقداردهی اولیه‌اش منتظر می‌ماند تا همهٔ مؤلفه‌هایش مقداردهی شوند. قاعده‌ای که باید رعایت شود این است که **هر مؤلفه باید تا پایان InitializeAsync مقداردهی شده باشد**. این تضمین می‌کند که تمامی انواع وابسته به‌عنوان بخشی از مقداردهی اولیهٔ ترکیبی مقداردهی شده‌اند. هر استثنایی که از مقداردهی اولیهٔ یک مؤلفه حاصل شود، به مقداردهی اولیهٔ نوع ترکیبی منتقل می‌شود.



### بحث
اگر ممکن است، توصیه می‌کنم به‌جای این راه‌حل از کارخانه‌های ناهمزمان (دستورالعمل 11.2) یا مقداردهی lazy ناهمزمان (دستورالعمل 14.1) استفاده کنید. این‌ها بهترین رویکردها هستند زیرا هرگز یک نمونهٔ مقداردهی‌نشده را در معرض قرار نمی‌دهند. با این حال، اگر نمونه‌های شما توسط تزریق وابستگی/وارونگی کنترل، data binding و غیره ایجاد می‌شوند، مجبور به افشای یک نمونهٔ مقداردهی‌نشده هستید و در این صورت من پیشنهاد می‌کنم از الگوی مقداردهی اولیهٔ ناهمزمان در این دستورالعمل استفاده کنید.

از دستورالعمل مربوط به رابط‌های ناهمزمان (دستورالعمل 11.1) به یاد داشته باشید که امضای یک متد ناهمزمان تنها به این معناست که پیاده‌سازی ممکن است ناهمزمان باشد. کد `MyComposedType.InitializeAsync` مثال خوبی از این مطلب است: اگر نمونهٔ `IMyFundamentalType` همچنین `IAsyncInitialization` را پیاده‌سازی نکند و `MyComposedType` خودش مقداردهی اولیهٔ ناهمزمانی نداشته باشد، آنگاه متد `InitializeAsync` آن به‌طور همزمان تکمیل می‌شود.

کدی برای بررسی اینکه آیا یک نمونه `IAsyncInitialization` را پیاده‌سازی می‌کند و مقداردهی اولیه‌اش می‌کند کمی دست‌وپاگیر است، و زمانی که یک نوع ترکیبی به تعداد بیشتری مؤلفه وابسته است این وضعیت پیچیده‌تر می‌شود. ایجاد یک متد کمکی برای ساده‌سازی کد کار آسانی است:

<div dir="ltr" align="left">


```csharp
public static class AsyncInitialization
{
    public static Task WhenAllInitializedAsync(params object[] instances)
    {
        return Task.WhenAll(instances
            .OfType<IAsyncInitialization>()
            .Select(x => x.Initialization));
    }
}
```

</div>

می‌توانید `InitializeAllAsync` را فراخوانی کنید و هر نمونه‌ای را که می‌خواهید مقداردهی شود پاس دهید؛ این متد نمونه‌هایی که `IAsyncInitialization` را پیاده‌سازی نمی‌کنند نادیده می‌گیرد. کد مقداردهی اولیهٔ یک نوع ترکیبی که به سه نمونهٔ تزریق‌شده وابسته است می‌تواند به این شکل باشد:

<div dir="ltr" align="left">


```csharp
private async Task InitializeAsync()
{
    // Asynchronously wait for all 3 instances to initialize, if necessary.
    await AsyncInitialization.WhenAllInitializedAsync(_fundamental,
        _anotherType, _yetAnother);
    // Do our own initialization (synchronous or asynchronous).
    ...
}
```
</div>

### مشاهده کنید
- دستورالعمل 11.2: کارخانه‌های ناهمزمان را پوشش می‌دهد، که روشی برای انجام ساخت ناهمزمان بدون افشای نمونه‌های مقداردهی‌نشده هستند.
- دستورالعمل 14.1: مقداردهی lazy ناهمزمان را پوشش می‌دهد که اگر نمونه یک منبع یا سرویس مشترک باشد قابل استفاده است.
- دستورالعمل 11.1: رابط‌های ناهمزمان را پوشش می‌دهد.



## ۱۱.۴ خصوصیت‌های ناهمزمان

### مسئله
شما یک خصوصیت (property) دارید که می‌خواهید آن را ناهمزمان کنید. این خصوصیت در data binding استفاده نمی‌شود.

### راه‌حل
این مشکلی است که هنگام تبدیل کد موجود به استفاده از async اغلب پیش می‌آید؛ در این وضعیت، گِترِ یک خصوصیت متدی را فراخوانی می‌کند که حالا ناهمزمان شده است. اما چیزی به‌نام «خصوصیت ناهمزمان» وجود ندارد. نمی‌توان از کلیدواژه async با یک خصوصیت استفاده کرد و این امر خوب است؛ گِترهای خصوصیت باید مقدار جاری را برگردانند و نباید عملیات پس‌زمینه‌ای را آغاز کنند:

<div dir="ltr" align="left">

```csharp
// چیزی که فکر می‌کنیم می‌خواهیم (قابلِ کامپایل نیست).
public int Data
{
    async get
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
        return 13;
    }
}
```

</div>

وقتی می‌بینید کدتان به «خصوصیت ناهمزمان» نیاز دارد، در واقع نیاز واقعی چیز دیگری است. راه‌حل بستگی دارد به اینکه مقدار خصوصیت باید یک‌بار ارزیابی شود یا هر بار خوانده شدن مجدداً ارزیابی گردد؛ شما بین این دو رفتار یکی را انتخاب می‌کنید:
- مقداری که هر بار خوانده شدن به‌صورت ناهمزمان ارزیابی می‌شود
- مقداری که یک‌بار به‌صورت ناهمزمان ارزیابی شده و برای دسترسی‌های بعدی کش می‌شود

اگر «خصوصیت ناهمزمان» شما باید هر بار خواندن، یک ارزیابی (ناهمزمان) جدید را آغاز کند، پس آن دیگر خصوصیت نیست؛ در واقع متدی مبدل‌شده به شکل دیگری است. اگر هنگام تبدیل کد همزمان به ناهمزمان به این وضعیت رسیدید، باید بپذیرید که طراحی اولیه نادرست بوده و آن باید از ابتدا متد می‌بود:

<div dir="ltr" align="left">


```csharp
// به‌عنوان یک متد ناهمزمان.
public async Task<int> GetDataAsync()
{
    await Task.Delay(TimeSpan.FromSeconds(1));
    return 13;
}
```

</div>

امکان بازگرداندن مستقیم `Task<int>` از یک خصوصیت نیز وجود دارد، همان‌طور که کد زیر نشان می‌دهد:

<div dir="ltr" align="left">


```csharp
// این "خصوصیت ناهمزمان" در واقع یک متد ناهمزمان است.
// این "خصوصیت ناهمزمان" خصوصیتی است که Task برمی‌گرداند.
public Task<int> Data
{
    get { return GetDataAsync(); }
}
private async Task<int> GetDataAsync()
{
    await Task.Delay(TimeSpan.FromSeconds(1));
    return 13;
}
```

</div>

با این حال من این رویکرد را توصیه نمی‌کنم. اگر هر دسترسی به یک خصوصیت قرار است یک عملیات ناهمزمان جدید را آغاز کند، آن «خصوصیت» در حقیقت باید یک متد باشد. این‌که آن را به‌صورت متد ناهمزمان نشان دهید وضوح بیشتری دارد و نشان می‌دهد که هر بار یک عملیات ناهمزمان جدید آغاز می‌شود تا رابط کاربری گمراه‌کننده نباشد. دستورالعمل‌های 11.3 و 11.6 از خصوصیت‌هایی که Task برمی‌گردانند استفاده می‌کنند، اما آن خصوصیت‌ها مربوط به نمونه به‌عنوان یک کل هستند و هر بار خواندن، عملیات ناهمزمان جدیدی را شروع نمی‌کنند.

گاهی می‌خواهید مقدار خصوصیت هربار که خوانده می‌شود ارزیابی شود. گاهی هم می‌خواهید تنها یک ارزیابی (ناهمزمان) انجام شود و آن مقدار نتیجه کش شده برای استفاده‌های بعدی نگهداری شود. در این حالت می‌توانید از مقداردهی lazy ناهمزمان استفاده کنید. این راه‌حل در دستورالعمل 14.1 به‌صورت مفصل پوشش داده شده، اما در اینجا مثالی از شکل کد می‌آورم:

<div dir="ltr" align="left">


```csharp
// به‌عنوان یک مقدار کش‌شده
public AsyncLazy<int> Data
{
    get { return _data; }
}
private readonly AsyncLazy<int> _data =
    new AsyncLazy<int>(async () =>
    {
        await Task.Delay(TimeSpan.FromSeconds(1));
        return 13;
    });
```

</div>

کد تنها یک‌بار ارزیابی ناهمزمان را اجرا می‌کند و سپس همان مقدار را به همهٔ فراخوان‌ها برمی‌گرداند. کد فراخوانی‌کننده به این صورت خواهد بود:

<div dir="ltr" align="left">


```csharp
int value = await instance.Data;
```
</div>

در این حالت، نحوۀ خصوصیت مناسب است چون تنها یک ارزیابی انجام می‌شود.

### بحث
یکی از سؤالات مهمی که باید از خود بپرسید این است که **آیا خواندن خصوصیت باید یک عملیات ناهمزمان جدید را آغاز کند**؛ اگر پاسخ مثبت است، به‌جای خصوصیت از یک متد ناهمزمان استفاده کنید. اگر خصوصیت باید به‌عنوان یک کش با ارزیابی lazy عمل کند، از مقداردهی اولیهٔ ناهمزمان استفاده کنید (رجوع کنید به دستورالعمل 14.1). در این دستورالعمل خصوصیت‌هایی که در data binding استفاده می‌شوند را پوشش ندادم؛ آن‌ها در دستورالعمل 14.3 آورده شده‌اند.

وقتی یک خصوصیت همزمان را به «خصوصیت ناهمزمان» تبدیل می‌کنید، این نمونه‌ای است از کاری که **نباید انجام دهید**:

<div dir="ltr" align="left">


```csharp
private async Task<int> GetDataAsync()
{
    await Task.Delay(TimeSpan.FromSeconds(1));
    return 13;
}

public int Data
{
    // BAD CODE!!
    get { return GetDataAsync().Result; }
}
```

</div>

در ادامهٔ موضوع خصوصیت‌ها در کد async، ارزش دارد دربارهٔ **نسبت وضعیت (state) با کد ناهمزمان** فکر کنید. این موضوع به‌ویژه وقتی اهمیت دارد که یک پایگاه کد همزمان را به ناهمزمان تبدیل می‌کنید. به هر حالتی که در API خود افشا می‌کنید (مثلاً از طریق خصوصیت‌ها)، برای هر قطعه وضعیت از خود بپرسید: **وضعیت جاری یک شیء که یک عملیات ناهمزمان در جریان دارد چیست؟** پاسخ صریحی وجود ندارد، اما مهم است که به **معناشناسی (semantics)** مورد نظر خود فکر کنید و آن‌ها را مستندسازی کنید.

برای مثال، `Stream.Position` را در نظر بگیرید که آفست جاری اشاره‌گر استریم را نشان می‌دهد. با API همزمان، وقتی `Stream.Read` یا `Stream.Write` را فراخوانی می‌کنید، خواندن/نوشتن انجام می‌شود و `Stream.Position` قبل از بازگشت متد `Read` یا `Write` به‌روزرسانی می‌شود. معناشناسی برای کد همزمان واضح است.

حالا `Stream.ReadAsync` و `Stream.WriteAsync` را در نظر بگیرید: **چه زمانی باید `Stream.Position` به‌روزرسانی شود؟** وقتی عملیات خواندن/نوشتن کامل شد، یا پیش از آنکه عملاً اتفاق بیفتد؟ اگر قبل از تکمیل عملیات به‌روزرسانی شود، آیا همزمان در زمان بازگشت `ReadAsync`/`WriteAsync` به‌روزرسانی شده است، یا ممکن است کمی پس از آن اتفاق بیفتد؟

این مثال خوبی است که نشان می‌دهد خصوصیتی که وضعیت را افشا می‌کند برای کد **همزمان معناشناسی کاملاً روشنی دارد اما برای کد ناهمزمان معناشناسی درست و آشکاری ندارد**. این پایان دنیا نیست — تنها باید به‌کل API خود هنگام فعال‌سازی async برای انواع فکر کنید و معناشناسی‌ای را که انتخاب می‌کنید مستندسازی نمایید.

### مشاهده کنید
- دستورالعمل 14.1: مقداردهی lazy ناهمزمان را به‌طور مفصل پوشش می‌دهد.
- دستورالعمل 14.3: «خصوصیت‌های ناهمزمان»ی را پوشش می‌دهد که نیاز به پشتیبانی از data binding دارند.


## ۱۱.۵ رویدادهای ناهمزمان
### مسئله
شما رویدادی دارید که باید با هندلرهایی استفاده شود که ممکن است ناهمزمان باشند و لازم است تشخیص دهید آیا هندلرهای رویداد کامل شده‌اند یا نه. توجه داشته باشید که این وضعیت هنگام برانگیختن یک رویداد نادر است؛ معمولاً وقتی رویدادی را فرا می‌خوانید، برایتان مهم نیست که هندلرها چه زمانی تکمیل می‌شوند.

### راه‌حل
تشخیص بازگشت هندلرهای async void عملی نیست، بنابراین باید راه جایگزینی برای تشخیص زمان تکمیل هندلرهای ناهمزمان پیدا کنید. پلتفرم Universal Windows مفهومِ deferral را معرفی کرد که می‌توانید از آن برای ردیابی هندلرهای ناهمزمان استفاده کنید. یک هندلر ناهمزمان قبل از اولین await خود یک deferral تخصیص می‌دهد و هنگام تکمیل شدن، به آن اطلاع می‌دهد. هندلرهای همزمان نیازی به استفاده از deferral ندارند.

کتابخانه Nito.AsyncEx نوعی به‌نام DeferralManager دارد که توسط مولّد رویداد (کامپوننتی که رویداد را برمی‌انگیزد) استفاده می‌شود. این DeferralManager به هندلرها اجازه می‌دهد deferral تخصیص دهند و پیگیری می‌کند که چه زمانی همهٔ deferralها تکمیل شده‌اند.

برای هر رویدادی که باید منتظر تکمیل هندلرها بمانید، ابتدا نوع آرگومان‌های رویداد را گسترش می‌دهید:


<div dir="ltr" align="left">


```csharp
public class MyEventArgs : EventArgs, IDeferralSource
{
    private readonly DeferralManager _deferrals = new DeferralManager();
    ... // سازنده‌ها و خصوصیات خودتان
    public IDisposable GetDeferral()
    {
        return _deferrals.DeferralSource.GetDeferral();
    }
    internal Task WaitForDeferralsAsync()
    {
        return _deferrals.WaitForDeferralsAsync();
    }
}
```
</div>

وقتی با هندلرهای رویداد ناهمزمان سروکار دارید، بهتر است نوع آرگومان‌های رویدادتان thread-safe باشد. ساده‌ترین راه برای این کار ساختن آن به‌صورت immutable (یعنی تمام خصوصیات readonly) است. سپس هر بار که رویداد را برمی‌انگیزید، می‌توانید (به‌صورت ناهمزمان) منتظر بمانید تا همهٔ هندلرهای ناهمزمان کامل شوند. کد زیر اگر هیچ هندلری وجود نداشته باشد یک Task تکمیل‌شده برمی‌گرداند؛ در غیر این صورت یک نمونهٔ جدید از نوع آرگومان‌ها می‌سازد، آن را به هندلرها می‌فرستد و منتظر تکمیل هر هندلر ناهمزمان می‌ماند:

<div dir="ltr" align="left">


```csharp
public event EventHandler<MyEventArgs> MyEvent;

private async Task RaiseMyEventAsync()
{
    EventHandler<MyEventArgs> handler = MyEvent;
    if (handler == null)
        return;
    var args = new MyEventArgs(...);
    handler(this, args);
    await args.WaitForDeferralsAsync();
}
```

</div>

هندلرهای ناهمزمان سپس می‌توانند داخل یک بلوک using از deferral استفاده کنند؛ وقتی deferral Dispose می‌شود، به DeferralManager اطلاع می‌دهد:

<div dir="ltr" align="left">


```csharp
async void AsyncHandler(object sender, MyEventArgs args)
{
    using IDisposable deferral = args.GetDeferral();
    await Task.Delay(TimeSpan.FromSeconds(2));
}
```

</div>

این کمی با نحوهٔ کار deferralها در Universal Windows تفاوت دارد. در API یونیورسال، هر رویدادی که نیاز به deferral دارد نوع deferral مخصوص به خود را تعریف می‌کند و آن نوع دارای متدی صریح به‌نام Complete است، نه اینکه IDisposable باشد.

### بحث
از نظر منطقی دو نوع رویداد مختلف در .NET وجود دارد که معناشناسی‌های بسیار متفاوتی دارند. من این‌ها را رویدادهای notification و رویدادهای command می‌نامم؛ این اصطلاحات رسمی نیستند، فقط برای روشن‌سازی انتخاب شده‌اند. یک رویداد notification برای اطلاع‌رسانی به سایر کامپوننت‌ها دربارهٔ یک وضعیت برانگیخته می‌شود. notification کاملاً یک‌طرفه است؛ فرستندهٔ رویداد اهمیت نمی‌دهد که دریافت‌کننده‌ای وجود دارد یا نه. با notification، فرستنده و گیرنده می‌توانند کاملاً از هم جدا باشند. بیشتر رویدادها از نوع notification هستند؛ مثالی از آن کلیک روی یک دکمه است.

در مقابل، یک رویداد command برای اجرای عملکردی به‌نمایندگی از کامپوننت فرستنده برانگیخته می‌شود. رویدادهای command در معنای واقعی «رویداد» نیستند، اگرچه اغلب به‌عنوان رویدادهای .NET پیاده‌سازی می‌شوند. فرستندهٔ یک command باید تا زمانی که گیرنده آن را پردازش کند منتظر بماند. اگر از رویدادها برای پیاده‌سازی الگوی Visitor استفاده کنید، آن‌ها رویدادهای command هستند. رویدادهای چرخهٔ حیات (lifecycle) نیز رویدادهای command محسوب می‌شوند، بنابراین رویدادهای چرخهٔ حیات صفحه در ASP.NET و بسیاری از رویدادهای فریم‌ورک‌های UI، مانند Application.PageAppearing در Xamarin، در این دسته قرار می‌گیرند. هر رویداد فریم‌ورک UI که در واقع یک پیاده‌سازی است نیز یک رویداد command است (مثلاً BackgroundWorker.DoWork).

رویدادهای notification نیازی به کد خاصی برای پشتیبانی از هندلرهای ناهمزمان ندارند؛ هندلرها می‌توانند async void باشند و به‌خوبی کار کنند. وقتی فرستندهٔ رویداد رویداد را برمی‌انگیزد، هندلرهای ناهمزمان فوراً کامل نمی‌شوند اما این مسئله اهمیت ندارد چون آن‌ها تنها notification هستند. بنابراین اگر رویداد شما notification است، مجموع کاری که باید برای حمایت از هندلرهای ناهمزمان انجام دهید: هیچ.

رویدادهای command داستان متفاوتی دارند. وقتی یک رویداد command دارید، باید راهی برای تشخیص زمان تکمیل هندلرها داشته باشید. راه‌حل پیشین با deferralها باید فقط برای رویدادهای command استفاده شود.

نکته
نوع DeferralManager در بستهٔ NuGet مربوط به Nito.AsyncEx وجود دارد.

مشاهده کنید
فصل 2 مبانی برنامه‌نویسی ناهمزمان را پوشش می‌دهد.

---

## ۱۱.۶ آزادسازی ناهمزمان (Async Disposal)
### مسئله
شما نوعی دارید که عملیات ناهمزمان انجام می‌دهد اما باید امکان آزادسازی (dispose) منابعش نیز فراهم باشد.

### راه‌حل
چند گزینهٔ رایج برای برخورد با عملیات جاری هنگام آزادسازی یک نمونه وجود دارد: یا آزادسازی را به‌عنوان یک درخواست لغو (cancellation) که بر همهٔ عملیات جاری اعمال می‌شود در نظر بگیرید، یا یک آزادسازی واقعی ناهمزمان پیاده‌سازی کنید.

در ویندوز سابقهٔ تاریخی وجود دارد که آزادسازی به‌عنوان لغو رفتار کند؛ انواعی مانند فایل‌استریم‌ها و سوکت‌ها هر خواندن یا نوشتن جاری را هنگام بسته شدن لغو می‌کنند. با تعریف یک CancellationTokenSource خصوصی و پاس‌دادن توکن آن به عملیات داخلی‌تان می‌توانید رفتار مشابهی در .NET داشته باشید. در کد زیر، Dispose عملیات را لغو می‌کند اما منتظر تمام شدن آن‌ها نمی‌ماند:

<div dir="ltr" align="left">


```csharp
class MyClass : IDisposable
{
    private readonly CancellationTokenSource _disposeCts =
        new CancellationTokenSource();

    public async Task<int> CalculateValueAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(2), _disposeCts.Token);
        return 13;
    }

    public void Dispose()
    {
        _disposeCts.Cancel();
    }
}
```

</div>

این کد الگوی پایه‌ای حول Dispose را نشان می‌دهد. در یک اپلیکیشن واقعی باید چک کنید که شی قبلاً Dispose نشده باشد و همچنین به کاربر اجازه دهید خودِ CancellationToken را تأمین کند (با استفاده از تکنیکی که در دستورالعمل 10.8 آمده):

<div dir="ltr" align="left">


```csharp
public async Task<int> CalculateValueAsync(CancellationToken cancellationToken)
{
    using CancellationTokenSource combinedCts =
        CancellationTokenSource
        .CreateLinkedTokenSource(cancellationToken, _disposeCts.Token);
    await Task.Delay(TimeSpan.FromSeconds(2), combinedCts.Token);
    return 13;
}
```

</div>

کد فراخوان وقتی Dispose صدا زده شود، هر عملیات جاری را لغو خواهد کرد:

<div dir="ltr" align="left">


```csharp
async Task UseMyClassAsync()
{
    Task<int> task;
    using (var resource = new MyClass())
    {
        task = resource.CalculateValueAsync(default);
    }
    // OperationCanceledException پرتاب می‌شود.
    var result = await task;
}
```

</div>

برای برخی انواع، پیاده‌سازی Dispose به‌صورت درخواست لغو کاملاً مناسب است (مثلاً HttpClient این معناشناسی را دارد). با این حال، برخی انواع نیاز دارند بدانند که همهٔ عملیات واقعاً کامل شده‌اند. برای این موارد به نوعی آزادسازی ناهمزمان نیاز دارید.

آزادسازی ناهمزمان تکنیکی است که با C# 8.0 و .NET Core 3.0 معرفی شد. BCL رابط جدید `IAsyncDisposable` را افزود که معادل ناهمزمان `IDisposable` است. زبان نیز هم‌زمان دستور `await using` را اضافه کرد که معادل ناهمزمان using است. بنابراین انواعی که می‌خواهند در هنگام آزادسازی کار ناهمزمان انجام دهند اکنون این امکان را دارند:

<div dir="ltr" align="left">


```csharp
class MyClass : IAsyncDisposable
{
    public async ValueTask DisposeAsync()
    {
        await Task.Delay(TimeSpan.FromSeconds(2));
    }
}
```

</div>

نوع بازگشتی `DisposeAsync` از نوع `ValueTask` است نه `Task`، ولی کلیدواژه‌های `async` و `await` به‌خوبی با `ValueTask` نیز کار می‌کنند.

انواعی که `IAsyncDisposable` را پیاده‌سازی می‌کنند معمولاً با `await using` مصرف می‌شوند:

<div dir="ltr" align="left">


```csharp
await using (var myClass = new MyClass())
{
    ...
} // اینجا DisposeAsync فراخوانی و await می‌شود.
```

</div>

اگر نیاز دارید از کانتکست جلوگیری کنید با `ConfigureAwait(false)`، امکان‌پذیر است اما کمی دست‌وپاگیرتر است چون باید متغیر را خارج از عبارت `await using` اعلان کنید:

<div dir="ltr" align="left">


```csharp
var myClass = new MyClass();
await using (myClass.ConfigureAwait(false))
{
    ...
} // اینجا DisposeAsync با ConfigureAwait(false) فراخوانی و await می‌شود.
```

</div>

### بحث
آزادسازی ناهمزمان قطعاً از پیاده‌سازی `Dispose` به‌صورت درخواست لغو آسان‌تر است، و روش پیچیده‌تر باید تنها وقتی استفاده شود که واقعاً به آن نیاز دارید. در واقع، در بسیاری موارد می‌توانید بدون آزادسازیِ صریح چیزی را رها کنید که ساده‌ترین راه است چون عملاً کاری انجام نمی‌دهید. این دستورالعمل دو الگو برای مدیریت آزادسازی ارائه می‌دهد و همچنین می‌توانید هر دو را هم‌زمان به‌کار ببرید. استفاده از هر دو به نوع شما این معناشناسی را می‌دهد که اگر کد کلاینت از `await using` استفاده کند، خاموش‌شدن تمیز خواهد بود، و اگر از `Dispose` استفاده کند، رفتار «لغو» رخ می‌دهد. به‌طور کلی این را توصیه نمی‌کنم، اما گزینه‌ای است که وجود دارد.

### مشاهده کنید
- دستورالعمل 10.8 توکن‌های لغو لینک‌شده را پوشش می‌دهد.
- دستورالعمل 11.1 رابط‌های ناهمزمان را پوشش می‌دهد.
- دستورالعمل 2.10 دربارهٔ پیاده‌سازی متدهایی که ValueTask برمی‌گردانند بحث می‌کند.
- دستورالعمل 2.7 دربارهٔ جلوگیری از کانتکست با ConfigureAwait(false) صحبت می‌کند.

</div>


