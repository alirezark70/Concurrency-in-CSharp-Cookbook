
<div dir="rtl" align="right">

# فصل ۱. همزمانی: یک مرور کلی

همزمانی یکی از جنبه‌های کلیدی و زیربنایی توسعه نرم‌افزار مدرن است. تا سال‌ها دستیابی به همزمانی، هرچند ممکن، کاری دشوار و پرزحمت بود. نوشتن و اشکال‌یابی برنامه‌های همزمان، پیچیده و زمان‌بر بود؛ به همین علت، بسیاری از توسعه‌دهندگان ترجیح می‌دادند از همزمانی صرف‌نظر کرده و مسیر ساده‌تر را برگزینند. اما امروزه، به لطف وجود کتابخانه‌ها و قابلیت‌هایی که در چهارچوب‌های مدرن .NET گنجانده شده، پیاده‌سازی همزمانی بسیار ساده‌تر شده است.  
مایکروسافت پیشگام تسهیل ورود توسعه‌دهندگان به دنیای همزمانی بوده است. در گذشته، برنامه‌نویسی همزمان، حوزه‌ای تخصصی و در انحصار کارشناسان بود؛ اما اکنون هر توسعه‌دهنده‌ای می‌تواند (و باید) همزمانی را در پروژه‌های خود بگنجاند.

---

## مقدمه‌ای بر همزمانی

پیش از ورود به بحث، لازم است برخی واژه‌ها و تعاریف کلیدی که در سراسر این کتاب استفاده خواهم کرد را شفاف بیان کنم. این تعاریف، چارچوبی یکدست برای تفاوت‌گذاری میان تکنیک‌های مختلف برنامه‌نویسی را فراهم می‌آورد.

**همزمانی**  
انجام بیش از یک کار در یک زمان.

همزمانی کاربردهای بی‌شماری دارد. برنامه‌های کاربری با بهره‌گیری از همزمانی می‌توانند همزمان با نوشتن داده‌ها در پایگاه داده، به ورودی کاربر پاسخ دهند. برنامه‌های سمت سرور نیز برای پاسخگویی به چندین درخواست، همزمانی را به‌کار می‌گیرند. هرگاه لازم باشد یک برنامه، وظایفی را به طور موازی با یکدیگر انجام دهد، همزمانی ضروری است ـ و تقریباً هر نرم‌افزاری در دنیا می‌تواند از مزایای آن بهره‌مند شود.

اغلب برنامه‌نویسان با شنیدن واژه «همزمانی»، بلافاصله به «چندریسمانی» (Multithreading) فکر می‌کنند. اما بهتر است بین این دو تمایز قائل شویم:

**چندریسمانی (Multithreading)**  
شکلی از همزمانی که در آن از چندین رشته اجرایی (Thread) استفاده می‌شود.

چندریسمانی به معنای واقعی، مبتنی بر اجرای هم‌زمان کد روی چندین Thread است. همان‌طور که در بخش‌های بعدی خواهید دید، چندریسمانی تنها یکی از اشکال همزمانی است و به هیچ عنوان یگانه راهکار نیست. حتی در اغلب برنامه‌های مدرن، استفاده مستقیم از نوع‌های سطح پایین ترد ضرورتی ندارد؛ انتزاع‌های سطح بالاتر، قدرتمندتر و کارآمدتر هستند. به همین خاطر در این کتاب، به حداقلِ پوشش مباحث منسوخ بسنده شده ‌است. هیچ‌کدام از نمونه‌های چندریسمانی این کتاب، مستقیماً از Thread یا BackgroundWorker بهره نمی‌برند، چراکه جایگزین‌های بهتر و مدرن وجود دارد.

> **هشدار:**  
> به محض آن‌که بنویسید `new Thread()` پروژه شما عملاً به یک کد میراثی (Legacy Code) تبدیل می‌شود!

البته این بدان معنی نیست که چندریسمانی مُرده است؛ Thread Pool همچنان به‌عنوان بستری پویا و بهینه برای صف‌بندی کارها و تخصیص منابع ایفای نقش می‌کند. Thread Pool همچنین لازمه گونه‌ای مهم از همزمانی است: «پردازش موازی».

**پردازش موازی (Parallel Processing)**  
تقسیم کارهای بزرگ به بخش‌های کوچکتر و اجرای همزمان آن‌ها روی چند ترد مستقل.

پردازش موازی (یا برنامه‌نویسی موازی) با بهره‌گیری از چندریسمانی، به برنامه‌ها اجازه می‌دهد به بهترین شکل از هسته‌های متعدد پردازنده بهره‌مند شوند. امروزه پردازنده‌ها چندین هسته دارند؛ اگر کار بزرگی دارید، عقلانی نیست که فقط یک هسته مشغول باشد و بقیه بدون استفاده بمانند. پردازش موازی، وظایف را بین تردها تقسیم می‌کند تا هر کدام روی هسته جداگانه اجرا شوند.

پردازش موازی، خود زیرمجموعه‌ای از چندریسمانی است و چندریسمانی نیز یکی از اشکال همزمانی است. اما یک گونه مهم دیگر از همزمانی، که معمولاً کمتر شناخته شده، برنامه‌نویسی ناهمگام است.

**برنامه‌نویسی ناهمگام (Asynchronous Programming)**  
شکلی از همزمانی که با استفاده از future یا callbackها، بدون نیاز به ترد اضافی عمل می‌کند.

future (یا promise) نوعی سازه است که نشان‌دهنده عملیاتی است که در آینده تکمیل خواهد شد. در #C و چارچوب .NET، این نوع با `Task` و `Task<TResult>` پیاده‌سازی می‌شود. APIهای ناهمگام قدیمی‌تر به‌جای futureها از callback یا event استفاده می‌کنند. اصل برنامه‌نویسی ناهمگام این است: کاری را آغاز می‌کنید که بعداً به پایان می‌رسد؛ در طول زمان اجرا، ترد اصلی می‌تواند آزادانه کارهای دیگری انجام دهد، و وقتی عملیات تکمیل شد، future یا callback/event به برنامه پایان را اطلاع می‌دهد.

تا پیش از فراگیر شدن عبارت‌های async و await، کدنویسی ناهمگام بسیار پیچیده بود. امروزه اما، این سبک برنامه‌نویسی تقریباً به سادگی اجرای ترتیبیِ عادی است.

در نهایت، نوعی دیگر از همزمانی وجود دارد که آموزش آن برای برنامه‌های مدرن حیاتی است:

**برنامه‌نویسی واکنشی (Reactive Programming)**  
همزمانی بر مبنای رویداد (Event)، جایی که رخدادها ممکن است چندین بار، در هر زمانی و بدون شروع مشخص رخ دهند.

برنامه‌نویسی ناهمگام غالباً به عملیاتی محدود می‌شود که یک‌بار شروع و یک‌بار پایان می‌یابند. اما برنامه‌نویسی واکنشی پیرامون رخدادهای ناهمگام بنا شده است؛ رخدادهایی که ممکن است در هر زمانی و دفعات متعدد به وقوع بپیوندند ـ مثالی ملموس برای آن ورود متناوب کاربر است.

---

</div>



### برنامه‌نویسی واکنشی (Reactive Programming)

**برنامه‌نویسی واکنشی** سبکی اعلانی از برنامه‌نویسی است که سامانه به رویدادها واکنش نشان می‌دهد. اگر یک برنامه را مجموعه‌ای از وضعیت‌ها در نظر بگیریم، رفتار آن را می‌توان به‌عنوان واکنش به انواع رویدادها و به‌روزرسانی وضعیت در هر رویداد توصیف کرد. این موضوع صرفاً یک تعریف انتزاعی یا نظری نیست؛ چرا که فریم‌ورک‌های مدرن، پیاده‌سازی عملی این رویکرد را ممکن ساخته‌اند.

هرچند برنامه‌نویسی واکنشی ذاتاً همزمان نیست، اما با همزمانی پیوند تنگاتنگی دارد. به همین دلیل، بخش‌هایی از رویکرد واکنشی در این کتاب آموزش داده می‌شود.

*در عمل، بیشتر برنامه‌های همزمان ترکیبی از چندین تکنیک را به کار می‌برند.* غالب سیستم‌ها دست‌کم از چندریسمانی (از طریق Thread Pool) و برنامه‌نویسی ناهمگام بهره می‌گیرند. شما می‌توانید هر ترکیب و رویکردی را که متناسب با الزامات بخش‌های مختلف برنامه است، استفاده کنید.

---

### مقدمه‌ای بر برنامه‌نویسی ناهمگام

**برنامه‌نویسی ناهمگام** (Asynchronous Programming) دو مزیت بنیادین دارد:

۱. **افزایش پاسخ‌گویی (Responsiveness) در برنامه‌های کاربری (GUI):**  
   همه ما تجربه هنگ کردن یا گیر کردن نرم‌افزارها را داشته‌ایم؛ اما با برنامه‌نویسی ناهمگام، حتی هنگام انجام کارهای زمان‌بر، برنامه همچنان می‌تواند به ورودی کاربر واکنش نشان دهد و رابط کاربری روان باقی می‌ماند.

۲. **افزایش مقیاس‌پذیری (Scalability) برنامه‌های سمت سرور:**  
   استفاده از Thread Pool تا حد قابل قبولی به مقیاس‌پذیری سرورها کمک می‌کند. اما برنامه‌های ناهمگام سروری عموماً به مراتب مقیاس‌پذیرتر هستند و می‌توانند به تعداد بیشتری درخواست با همان منابع سخت‌افزاری پاسخ دهند.

هر دو مزیت فوق، ریشه در یک اصل کلیدی دارند:  
**برنامه‌نویسی ناهمگام موجب می‌شود Thread اشغال نشود و آزاد بماند.**  
در برنامه‌های کاربری، این Thread همان UI Thread است؛ بنابراین نرم‌افزار می‌تواند همواره آماده پذیرش فرمان‌های کاربر باشد. در سمت سرور نیز با آزادسازی Thread هر درخواست، سیستم می‌تواند تعداد بیشتری درخواست را همزمان مدیریت کند.

---

#### کلیدواژه‌های مهم: async و await

در برنامه‌های ناهمگام مدرن #C/.NET، دو کلیدواژه‌ی مهم داریم:  
**async** و **await**

- `async` به امضای متد افزوده می‌شود و دو نقش حیاتی دارد:  
    ۱. اجازه می‌دهد از `await` در همان متد استفاده شود.  
    ۲. به کامپایلر اطلاع می‌دهد تا برای آن متد یک ماشین حالت (state machine) بسازد (مشابه عملکرد `yield return`).  
- متدی که خروجی دارد، خروجی‌اش از نوع `Task<TResult>` خواهد بود؛ اگر خروجی نداشته باشد، از نوع `Task`، یا در موارد خاص، انواع شبیه‌تسک مانند `ValueTask`.  
- همچنین اگر متد async چند مقدار در قالب enumeration بازمی‌گرداند، خروجی آن می‌تواند `IAsyncEnumerable<T>` یا `IAsyncEnumerator<T>` باشد.  
- انواع شبیه‌تسک (task-like types) همان آینده‌ها (future) هستند که پس از اتمام متد async، به کد فراخواننده اطلاع می‌دهند.

---

</div>



---

## هشدار

**از `async void` دوری کنید!**  
اگرچه ممکن است یک متد async با خروجی void تعریف شود، اما این کار فقط باید برای event handlerهای ناهمگام انجام گیرد. در برنامه‌نویسی عادی، متدهای async که خروجی ندارند باید `Task` را بازگردانند، نه void.

---

## یک مثال پایه از متد async

<div dir="ltr" align="left">


```csharp
async Task DoSomethingAsync()
{
    int value = 13;
    // به‌صورت ناهمگام ۱ ثانیه منتظر بمان.
    await Task.Delay(TimeSpan.FromSeconds(1));
    value *= 2;
    // به‌صورت ناهمگام ۱ ثانیه منتظر بمان.
    await Task.Delay(TimeSpan.FromSeconds(1));
    Trace.WriteLine(value);
}
```
</div>
یک متد async دقیقاً مانند یک متد عادی، به‌صورت همزمان (Synchronous) آغاز به اجرا می‌کند. درون متد async، هر `await` یک "انتظار ناهمگام" روی آرگومان خود انجام می‌دهد: ابتدا بررسی می‌کند که آیا عملیات موردنظر قبلاً تکمیل شده یا خیر؛ اگر تکمیل شده باشد، اجرا ادامه می‌یابد. در غیر این صورت، متد async متوقف شده و یک تسک ناقص برمی‌گرداند. پس از پایان عملیات async، اجرای متد نیز ادامه پیدا می‌کند.

می‌توانید متد async را به‌صورت چند بخش همزمان در نظر بگیرید که این بخش‌ها با `await` از هم جدا می‌شوند. قسمت نخست روی همان تردی اجرا می‌شود که متد فراخوانی شده است؛ اما تداوم بخش‌های بعدی اجرای متد بر روی چه تردی صورت می‌گیرد؟ پاسخ به این پرسش کمی پیچیده است:

---

## درباره context در متدهای async

وقتی یک تسک را await می‌کنید (و این رایج‌ترین سناریو است)، یک context از لحظه توقف اجرا ثبت می‌شود. این context معمولاً همان `SynchronizationContext` جاری است (مگر اینکه مقدار آن null باشد که در این‌صورت context همان `TaskScheduler` خواهد بود). ادامه متد، درست در همان context اجرا می‌شود:  
- اغلب اوقات، context مربوط به UI thread است؛  
- گاهی دیگر context مربوط به thread pool است.  
- در برنامه‌های ASP.NET Classic، context می‌تواند context درخواست باشد.  
- در ASP.NET Core، تنها context thread pool استفاده می‌شود.

در مثال بالا، همه بخش‌های async سعی می‌کنند روی همان context اولیه ادامه پیدا کنند. اگر DoSomethingAsync را از ترد UI اجرا کنید، این بخش‌ها هم روی ترد UI اجرا می‌شوند. اگر از thread pool فراخوانی شود، هر بخش ممکن است روی یک ترد متفاوت از thread pool اجرا گردد.

می‌توانید این رفتار پیش‌فرض را با استفاده از متد `ConfigureAwait` و مقدار false برای پارامتر `continueOnCapturedContext` تغییر دهید. نمونه زیر را ببینید:

<div dir="ltr" align="left">


```csharp
async Task DoSomethingAsync()
{
    int value = 13;
    // به‌صورت ناهمگام ۱ ثانیه منتظر بمان، بدون حفظ context اولیه.
    await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);
    value *= 2;
    await Task.Delay(TimeSpan.FromSeconds(1)).ConfigureAwait(false);
    Trace.WriteLine(value);
}
```
</div>

**نکته:**  
توصیه می‌شود همواره در متدهای کتابخانه‌ای خود از `ConfigureAwait(false)` استفاده کنید و فقط در بخش‌های رابط کاربری یا جایی که واقعاً به context نیاز دارید، اجازه دهید context حفظ شود.

---

## await فقط برای Task نیست

کلیدواژه `await` تنها مختص Taskها نیست؛ هر شیء "awaitable" که الگوی await را پیاده‌سازی کرده باشد (مانند ValueTask<T>) قابل استفاده است. (برای مثال: ValueTask<T> برای کاهش تخصیص حافظه در سناریوهایی مانند cache در حافظه بسیار مفید است.) توجه داشته باشید ValueTask<T> مستقیماً به Task<T> تبدیل نمی‌شود اما از await پشتیبانی می‌کند. با این حال، در اکثر موارد، await را برای Task یا Task<TResult> استفاده خواهید کرد.

---

## راه‌های ساختن Task

دو راه عمده برای ساخت Task وجود دارد:

*Taskهایی که برای اجرای کد CPU ساخته می‌شوند*:  
با استفاده از `Task.Run` (یا اگر نیاز به Scheduler خاص دارید، با TaskFactory.StartNew).

*Taskهایی که نقش اعلان (notification) دارند*:  
معمولاً با `TaskCompletionSource<TResult>` ساخته می‌شوند؛ بیشتر عملیات I/O مدرن از این مدل بهره می‌گیرند.

---

## مدیریت خطا در async و await

خطایابی در async و await بسیار طبیعی و نزدیک به تجربه معمول sync است. فرض کنید تابع PossibleExceptionAsync ممکن است خطا بیندازد و شما می‌خواهید آن را مدیریت کنید:

<div dir="ltr" align="left">


```csharp
async Task TrySomethingAsync()
{
    try
    {
        await PossibleExceptionAsync();
    }
    catch (NotSupportedException ex)
    {
        LogException(ex);
        throw;
    }
}

```
</div>

در متد async، اگر خطایی رخ دهد، exception روی Task قرار می‌گیرد و پس از await، به‌شکل صحیح و با حفظ استک‌تریس پرتاپ می‌شود.  
در کدی مشابه زیر، در صورتی که PossibleExceptionAsync یک متد async باشد، اتفاقی که انتظارش را دارید رخ می‌دهد:

<div dir="ltr" align="left">


```csharp
async Task TrySomethingAsync()
{
    // exception روی Task قرار می‌گیرد، نه بلافاصله پرتاب می‌شود.
    Task task = PossibleExceptionAsync();
    try
    {
        // استثناء زمانی اتفاق می‌افتد که await انجام می‌شود.
        await task;
    }
    catch (NotSupportedException ex)
    {
        LogException(ex);
        throw;
    }
}
```
</div>


## اجتناب از بن‌بست (Deadlock) در کد async

وقتی در کدتان از async استفاده کردید، توصیه می‌شود همان منطق را تا پایان پروژه حفظ کنید و به سراغ روش‌های سنتی انتظار برای نتیجه (مانند Task.Wait, Task<TResult>.Result یا GetAwaiter().GetResult()) نروید، چرا که ممکن است باعث بن‌بست شود.

### مثال بن‌بست:

<div dir="ltr" align="left">


```csharp
async Task WaitAsync()
{
    // این await context فعلی را ثبت می‌کند ...
    await Task.Delay(TimeSpan.FromSeconds(1));
    // ... و سعی می‌کند ادامه متد را در همان context اجرا کند.
}

void Deadlock()
{
    // delay را آغاز می‌کند.
    Task task = WaitAsync();
    // با مسدود کردن thread منتظر اتمام متد async می‌ماند.
    task.Wait();
}
```
</div>

کد بالا اگر از UI context یا ASP.NET Classic اجراء شود دچار بن‌بست (Deadlock) خواهد شد، چرا که هر دو context فقط یک thread را همزمان قبول می‌کنند. Deadlock با WaitAsync شروع می‌شود و معطل اتمامش می‌ماند؛ ولی وقتی Delay تمام می‌شود، await تلاش می‌کند ادامه WaitAsync را در همان context اجرا کند که به دلیل مسدود بودن context ممکن نیست. جلوگیری از این مشکل با استفاده از ConfigureAwait(false) در WaitAsync یا await مستقیم task امکان‌پذیر است.

---

## هشدار پایانی

اگر مسیر async را در پیش گرفتید، تا پایان همین رویکرد را دنبال کنید و ترجیحاً در کد خود همواره await کنید.

---

</div>

---

## یادگیری بیشتر درباره async

برای یادگیری عمیق‌تر درباره async، [اسناد آنلاین مایکروسافت](https://learn.microsoft.com/) منبعی ارزشمند و قابل‌اعتماد است. پیشنهاد می‌کنم دست‌کم بخش‌های زیر را مطالعه کنید:
- **Asynchronous Programming Overview**
- **Task-based Asynchronous Pattern (TAP) Overview**
اگر علاقه‌مند بودید، بخش **Async in Depth** نیز مرجع خوبی محسوب می‌شود.

---

## جریان‌های ناهمگام (Asynchronous Streams)

جریان ناهمگام، پایه‌های `async` و `await` را بسط داده و برای دریافت چندین مقدار مورد استفاده قرار می‌گیرد. این تکنیک، مبتنی بر enumerableهای ناهمگام است؛ ساختاری شبیه enumerableهای معمولی، با این تفاوت که هر بار مقدار بعدی sequence را به‌صورت ناهمگام دریافت و پردازش می‌کند.

جریان ناهمگام مفهومی بسیار قدرتمند است که در فصل ۳ به‌تفصیل شرح داده خواهد شد. این رویکرد زمانی به کار می‌آید که داده‌ها به صورت تکی یا دسته‌ای به برنامه می‌رسند؛ به‌عنوان مثال، زمانی‌که با یک API تعامل می‌کنید که پاسخ‌ها را با پارامترهایی مانند paging (مانند limit/offset) ارسال می‌کند، asynchronous stream انتخابی عالی است.  
در زمان نگارش این کتاب، جریان‌های ناهمگام عمدتاً روی نسخه‌های جدید .NET در دسترس هستند.

---

## مقدمه‌ای بر برنامه‌نویسی موازی

برنامه‌نویسی موازی زمانی مفید است که حجم قابل‌توجهی از کار محاسباتی دارید که قابلیت تقسیم به بخش‌های مستقل را دارد. در این رویکرد میزان استفاده از CPU موقتاً افزایش پیدا می‌کند تا بازده کلی (Throughput) سیستم بهبود یابد؛ این ویژگی در کلاینت‌هایی که اغلب ظرفیت CPU آنها بی‌استفاده می‌ماند، سودمند است. معمولاً در سرورها، موازی‌سازی چندان ضرورتی ندارد؛ زیرا بیشتر سرورها به‌طور پیش‌فرض از موازی‌سازی داخلی بهره می‌برند؛ برای مثال، **ASP.NET** همزمان چند درخواست را به شکل موازی مدیریت می‌کند.

در برخی سناریوها ـ مثلاً زمانی که مطمئن هستید تعداد کاربران همزمان همیشه پایین باقی می‌ماند ـ پیاده‌سازی کد موازی روی سرور مفید است. اما در بیشتر مواقع، موازی‌سازی مستقیم در سرویس‌ها می‌تواند با موازی‌سازی داخلی سرور تداخل داشته باشد و کارایی خاصی به‌همراه نیاورد.

---

### انواع موازی‌سازی

دو نوع اصلی موازی‌سازی وجود دارد:

- **موازی‌سازی داده‌ای (Data Parallelism):**  
  زمانی که مجموعه‌ای از داده‌ها در اختیار دارید و پردازش هر قسمت مستقل از سایر بخش‌هاست.
- **موازی‌سازی وظیفه‌ای (Task Parallelism):**  
  زمانی کاربرد دارد که چندین کار مختلف برای اجرا در اختیار است و هرکدام نسبتاً مستقل هستند. وظایف ممکن است پویا باشند؛ به این معنی که یک کار می‌تواند چندین کار جدید ایجاد کند و به صف اضافه کند.

---

### راه‌های اجرای موازی‌سازی داده‌ای

یکی از رایج‌ترین راه‌ها برای پیاده‌سازی موازی‌سازی داده‌ای استفاده از `Parallel.ForEach` است:

<div dir="ltr" align="left">


```csharp
void RotateMatrices(IEnumerable<Matrix> matrices, float degrees)
{
    Parallel.ForEach(matrices, matrix => matrix.Rotate(degrees));
}
```
</div>

اگر نیاز به پردازش وابسته به اندیس باشد، می‌توانید از `Parallel.For` بهره ببرید.

راه دیگر، استفاده از **PLINQ** (Parallel LINQ) است که با متد `AsParallel` کوئری‌های LINQ را موازی می‌کند:


<div dir="ltr" align="left">


```csharp
IEnumerable<bool> PrimalityTest(IEnumerable<int> values)
{
    return values.AsParallel().Select(value => IsPrime(value));
}
```
- **Parallel** رفتار ملایم‌تری با منابع سیستم دارد و کمتر مزاحم سایر فرآیندها می‌شود.
- **PLINQ** معمولاً تلاش می‌کند تمام هسته‌های پردازنده را درگیر کند و کد خواناتری ایجاد می‌کند.

---
</div>

#### نکته مهم:
قطعات کار موازی باید تا حد ممکن مستقل باشند؛  
هرچه استقلال کارها بیشتر باشد، موازی‌سازی اثربخش‌تر خواهد بود. در غیر این ‌صورت، باید وضعیت‌ها و داده‌های مشترک را با Synchronization مدیریت کنید که هم موازی‌سازی را کاهش می‌دهد و هم پیچیدگی کد را بیشتر می‌کند (جزییات بیشتر در فصل ۱۲).

خروجی پردازش موازی می‌تواند در کالکشن‌های هم‌روند (Concurrent Collections) ذخیره شود یا با عملیات **Aggregation** به نتیجه‌ای خلاصه تبدیل گردد. Aggregation در موازی‌سازی رایج است و قابلیت‌هایی مانند **map/reduce** نیز به‌کمک پارالل قابل اجراست (توضیحات کامل در بخش Recipe 4.2).

---

## موازی‌سازی وظیفه‌ای (Task Parallelism)

موازی‌سازی داده‌ای بر پردازش دسته‌ای داده‌ها تمرکز دارد؛ اما موازی‌سازی وظیفه‌ای صرف اجرای وظایف مستقل در کنار هم است.  
در بسیاری از مسائل واقعی، امکان حل مسئله با هر دو رویکرد وجود دارد؛ آنچه مهم است انتخاب رویکرد مناسب متناسب با سناریو و ویژگی‌های مسئله است.

---

</div>

---

## Parallel.Invoke و موازی‌سازی وظیفه‌ای (fork/join)

یکی از متدهای مهم کلاس `Parallel`، متد `Parallel.Invoke` است که پیاده‌سازی موازی‌سازی وظیفه‌ای از نوع fork/join را ساده می‌کند (توضیحات تکمیلی در Recipe 4.3):

<div dir="ltr" align="left">

```csharp
void ProcessArray(double[] array)
{
    Parallel.Invoke(
        () => ProcessPartialArray(array, 0, array.Length / 2),
        () => ProcessPartialArray(array, array.Length / 2, array.Length)
    );
}

void ProcessPartialArray(double[] array, int begin, int end)
{
    // پردازش محاسباتی سنگین (CPU-intensive) ...
}
```
</div>


## آشنایی با Task در موازی‌سازی و برنامه‌نویسی ناهمگام

نوع `Task` ابتدا با هدف پیاده‌سازی موازی‌سازی وظیفه‌ای معرفی شد، اما امروزه کاربرد وسیعی در برنامه‌نویسی ناهمگام نیز دارد. یک Task نماینده‌ی بخشی از کار است:

- با متد `Wait` می‌توانید منتظر اتمام Task بمانید.
- با ویژگی‌های `Result` و `Exception`، نتیجه یا خطا را به‌دست آورید.

استفاده مستقیم از Task پیچیده‌تر از Parallel است، اما برای موازی‌سازی‌هایی که ساختار پویا دارند و میزان کار در لحظه اجرا مشخص می‌شود، بسیار مفید است.  
برای مثال: وقتی ابتدای پردازش، دقیقاً مشخص نیست چند کار باید انجام شود و این کارها در طول اجرا مرحله‌به‌مرحله کشف می‌شوند.  
هر کار پویا می‌تواند child taskهای خود را راه‌اندازی کند و در انتها منتظر اتمام همه‌ی آنها بماند.  
یک تنظیم خاص برای همبستگی parent/child، با نام `TaskCreationOptions.AttachedToParent` وجود دارد (توضیحات بیشتر در Recipe 4.4).

---

## نکات کارایی در موازی‌سازی وظیفه‌ای

همانند موازی‌سازی داده‌ای، در موازی‌سازی وظیفه‌ای نیز باید تا حد امکان بر استقلال وظایف تأکید نمود تا کارایی حفظ شود.  
هر چه delegateهای شما مستقلتر باشند، بهره‌وری سیستم بالاتر است؛ در غیر این صورت مجبور به synchronization مکرر خواهید شد که هم نگارش کد را دشوارتر و هم سرعت اجرا را کاهش می‌دهد.  
در موازی‌سازی وظیفه‌ای، مراقب closureها باشید؛ متغیرهایی که توسط closureها capture می‌شوند می‌توانند موجب اشتراک ناخواسته و ایجاد باگ‌های ریز شوند.

---

## مدیریت خطا در موازی‌سازی

مدیریت خطا در تمام انواع موازی‌سازی ساختار مشابهی دارد.  
از آنجا که عملیات‌ها به صورت همزمان اجرا می‌شوند، احتمال بروز چندین خطا زیاد است؛ همه‌ی این خطاها در قالب `AggregateException` جمع‌آوری و یکباره پرتاب می‌شوند (این رفتار در متدهای `Parallel.ForEach`، `Parallel.Invoke`، `Task.Wait` و ... یکسان است).  
کلاس `AggregateException` متدهای کمکی مانند `Flatten` و `Handle` را برای ساده‌سازی مدیریت استثناها ارائه می دهد:

<div dir="ltr" align="left">

```csharp
try
{
    Parallel.Invoke(() => { throw new Exception(); }, () => { throw new Exception(); });
}
catch (AggregateException ex)
{
    ex.Handle(exception =>
    {
        Trace.WriteLine(exception);
        return true; // "handled"
    });
}
```
</div>
---

## مدیریت تردها و راندمان

در اغلب مواقع، نیاز نیست نگران تقسیم کار بین تردها یا مدیریت thread pool باشید؛  
موازی‌سازی داده‌ای و وظیفه‌ای با استفاده از پارتیشنرهای پویا کارها را بین تردهای worker تقسیم می‌کنند، و thread pool به‌صورت خودکار تعداد threadها را تنظیم می‌کند.  
هر ترد worker یک صف کار جداگانه دارد و چنانچه بیکار شود، دستور انجام کار از صف threadهای دیگر را می‌رباید (stealing). مایکروسافت زمان و تلاش زیادی صرف بهینه‌سازی thread pool کرده و در بیشتر سناریوها تنظیمات پیش‌فرض کفایت می‌کند (مگر آنکه کارها بسیار کوتاه یا به شدت طولانی شوند).

---

### نکته:

**وظایف موازی نه باید بیش از حد کوتاه و نه بسیار طولانی باشند.**  
اگر خیلی کوتاه باشند، سربار تقسیم کار و زمان‌بندی بر عملکرد غالب می‌شود. اگر خیلی طولانی باشند، thread pool توانایی بالانس کردن بار سیستم را به‌درستی نخواهد داشت. میزان بهینه وابسته به سخت افزار و سناریوی شماست.  
عمومأ کارها باید تا جایی کوتاه شوند که سرعت برنامه کاهش محسوسی نیابد.  
در کل، توصیه می‌شود به‌جای کار مستقیم با Taskها، تا حد ممکن از Parallel یا PLINQ استفاده کنید؛ زیرا این ابزارها مدیریت پارتیشن‌بندی و بهره‌برداری مؤثر را به‌طور خودکار انجام می‌دهند.

---

</div>

---

## مقدمه‌ای بر برنامه‌نویسی واکنشی (Rx)

برنامه‌نویسی واکنشی نسبت به دیگر الگوهای همزمانی، منحنی یادگیری نسبتاً بالاتری دارد و نگهداری کدهای آن بدون به‌روز‌رسانی مداوم مهارت‌ها دشوار می‌شود. با این حال، اگر حاضر به یادگیری باشید، Rx فوق‌العاده قدرتمند است. این شیوه به شما امکان می‌دهد جریان رویدادها را همانند داده‌ها مدیریت کنید.  
به‌عنوان یک قاعده، اگر هر یک از آرگومان‌های رویداد را لازم دارید، بهتر است به‌جای event handler سنتی، از System.Reactive بهره ببرید.

> **نکته:**  
> System.Reactive پیش‌تر با نام Reactive Extensions (یا مخففاً Rx) شناخته می‌شد. هر سه اصطلاح به همین فناوری اشاره دارند.

برنامه‌نویسی واکنشی بر مبنای مفهوم جریان‌های observable است. وقتی بر یک جریان observable مشترک می‌شوید (subscribe)، می‌توانید صفر تا بی‌نهایت آیتم داده دریافت کنید (`OnNext`)، سپس جریان ممکن است با یک خطا (`OnError`) یا پیام "پایان" (`OnCompleted`) خاتمه یابد. برخی جریان‌ها ممکن است هرگز پایان نیابند.

اینترفیس‌های اصلی Rx به‌شکل زیر هستند:

<div dir="ltr" align="left">

```csharp
interface IObserver<in T>
{
    void OnNext(T item);
    void OnCompleted();
    void OnError(Exception error);
}
interface IObservable<out T>
{
    IDisposable Subscribe(IObserver<T> observer);
}
```
</div>


> معمولاً نباید این اینترفیس‌ها را خودتان پیاده‌سازی کنید؛ کتابخانه System.Reactive (ساخته Microsoft) همهٔ نیازهای لازم را پوشش داده است.

کدهای Rx غالباً شبیه LINQ هستند؛ در حقیقت، Rx همان "LINQ برای رویدادها" است!  
System.Reactive تمام عملیات LINQ و حتی اپراتورهای بیشتری (خصوصاً برای کار با زمان) را به‌ همراه دارد.  
کد نمونه زیر با عملگرهایی شروع می‌شود که ممکن است با آن‌ها آشنا نباشید (Interval و Timestamp)، اما Where و Select همان LINQ استاندارد هستند:

<div dir="ltr" align="left">

```csharp
Observable.Interval(TimeSpan.FromSeconds(1))
    .Timestamp()
    .Where(x => x.Value % 2 == 0)
    .Select(x => x.Timestamp)
    .Subscribe(x => Trace.WriteLine(x));
```
</div>

در این کد، شمارنده‌ای با یک تایمر دوره‌ای (`Interval`) آغاز می‌شود، هر رویداد یک زمان سنجی (`Timestamp`) می‌گیرد، فقط رویدادهای زوج (`Where`) انتخاب می‌شوند، تنها زمان‌ها (`Select`) جدا شده و خروجی به debugger ارسال می‌گردد (`Subscribe`).

نگران عملگرهای جدید نباشید؛ آموزش آنها در ادامه کتاب خواهد آمد. فعلاً کافی است بدانید این فقط یک کوئری LINQ است که روی رویدادها و نه داده‌ها اعمال می‌شود.  
تفاوت بنیادی Rx با LINQ سنتی در مدل اجراست: LINQ برای موجودیت‌ها و آبجکت‌ها مدل کششی (pull) است (داده باید "خوانده شود")، اما Rx/رویدادها مدل فشاری (push) دارند (رویدادها به جریان می‌آیند).

تعریف یک جریان observable مستقل از subscriptionهای آن است. مثال بالا را می‌توان به‌شکل زیر نیز نوشت:

<div dir="ltr" align="left">

```csharp
IObservable<DateTimeOffset> timestamps =
    Observable.Interval(TimeSpan.FromSeconds(1))
        .Timestamp()
        .Where(x => x.Value % 2 == 0)
        .Select(x => x.Timestamp);

timestamps.Subscribe(x => Trace.WriteLine(x));
```
</div>

در عمل توصیه می‌شود streamهای observable را به‌صورت خاص خودتان تعریف و تولید کنید و آن‌ها را به شکل `IObservable<T>` در اختیار سایر ماژول‌ها بگذارید. سایر بخش‌های برنامه می‌توانند روی آن‌ها subscribe کنند یا با اپراتورهای دیگر، جریان‌های جدیدی بسازند.

هر subscription در System.Reactive نیز یک resource تلقی می‌شود. عملگر Subscribe یک IDisposable بازمی‌گرداند که نماینده اشتراک است؛ هرگاه دیگر به داده‌های جریان نیاز نداشتید، لازم است آن resource را آزاد (Dispose) کنید.

**رفتار subscription بسته به "داغ" (hot) یا "سرد" (cold) بودن observable متفاوت است:**

- **observable داغ (hot):** جریانی که به‌طور مداوم رخ می‌دهد و اگر هنگام وقوع رویداد مشترکی وجود نداشته باشد، آن رویداد از دست می‌رود (مانند امکان دریافت رویداد حرکت ماوس).
- **observable سرد (cold):** جریانی که هر زمان مشترکی پیدا کند، شروع به ایجاد رویداد می‌کند (مانند دانلود HTTP یا بازخوانی فایل).

برای کار حرفه‌ای‌تر با subscription و مدیریت خطا، می‌توانید پارامتر مدیریت خطا را نیز به Subscribe بدهید؛ مثلاً:

<div dir="ltr" align="left">

```csharp
Observable.Interval(TimeSpan.FromSeconds(1))
    .Timestamp()
    .Where(x => x.Value % 2 == 0)
    .Select(x => x.Timestamp)
    .Subscribe(
        x => Trace.WriteLine(x),
        ex => Trace.WriteLine(ex)
    );
```
</div>

**Subject\<T>** در Rx، ابزاری عالی برای تست است. این نوع، یک observable دستی فراهم می‌کند؛ شما می‌توانید متدهای `OnNext`، `OnError` و `OnCompleted` را مستقیماً روی subject صدا بزنید، و همه subscriberها آنها را دریافت خواهند کرد. Subject\<T> انتخاب مطلوبی برای تست است اما در برنامه‌های production اکیداً پیشنهاد می‌شود تا حد امکان به جای آن، از اپراتورهای آماده‌ای که در فصل ۶ معرفی می‌شود استفاده کنید.

---

</div>




<div dir="rtl" align="right">

---

## مقدمه‌ای بر Dataflow

**TPL Dataflow** ترکیبی قدرتمند از فناوری‌های ناهمگام و موازی در چارچوب دات‌نت است. این فناوری هر جا لازم باشد مجموعه‌ای از فرایندها به‌ترتیب روی داده‌های شما انجام شود، ارزشمند است؛ برای مثال: دانلود داده از URL، پارس آن و سپس پردازش موازی بر خروجی.  
بسیاری مواقع، استفاده‌ی TPL Dataflow شبیه یک «خط لوله» (pipeline) ساده است: داده‌ از یک سمت وارد می‌شود و مرحله به مرحله تا انتها پیش می‌رود؛ اما قابلیت‌های Dataflow بسیار فراتر از این کاربرد ساده است:  
قادر خواهید بود هر گونه ساختار «مش» (mesh) داده‌ای دلخواه شامل انشعاب (fork)، ادغام (join)، یا حتی حلقه (loop) را بسازید و Dataflow تمام پیچیدگی‌ها را مدیریت می‌کند. با این حال، اکثر سناریوها به صورت pipeline‌ پیاده می‌شوند.

### ساختار پایه: Dataflow Block

واحد اصلی در یک مش داده‌ای Dataflow، چیزی به نام **داده‌بلوک (Dataflow block)** است. هر بلوک می‌تواند «منبع» (source)، «هدف» (target)، یا هر دو باشد. بلوک‌های منبع را می‌توان به بلوک‌های هدف متصل کرد تا ساختار مش ایجاد شود (اتصال در Recipe 5.1 شرح داده می‌شود).  
هر بلوک تاحدودی مستقل است: هنگام دریافت داده، سعی می‌کند آن را سریعاً پردازش کند و نتیجه را به بلوک بعدی انتقال دهد.

### روند استفاده معمول

ابتدا همه‌ی بلوک‌ها را تعریف و به‌هم وصل می‌کنید؛ سپس از یک سمت داده را وارد جریان می‌نمایید. داده‌ها نیز به‌تدریج از سمت دیگر خارج خواهند شد.  
Dataflow از این حد هم فراتر می‌رود؛ حتی می‌توانید حین اجرای جریان داده، اتصالات را قطع و وصل کنید، یا بلوک‌های جدیدی به مش بیفزایید (سناریوهای پیشرفته).

### رفتار buffer و انشعاب (fork)

بلوک‌های target درون خود بافر دارند، یعنی می‌توانند داده را دریافت کنند حتی اگر فوراً آماده پردازش نباشند. این ویژگی باعث پایداری جریان می‌شود؛ اما در سناریوی fork (یک منبع به چند هدف متصل است)، این رفتار می‌تواند دردسرساز شود:  
اگر یکی از بلوک‌های target داده را بافر کند، بقیه targets ممکن است اصلاً به داده دسترسی پیدا نکنند. راه‌حل، محدود ساختن بافر target یا nongreedy کردن آنهاست (در Recipe 5.4 توضیحات بیشتر).

### مدیریت خطا در Dataflow

اگر هنگام پردازش، delegate یا تابع شما خطا بدهد، بلوک موردنظر در حالت fault قرار می‌گیرد ـ داده‌ی جدید نمی‌پذیرد، ولی بقیه مش را پیش‌فرض خراب نمی‌کند تا امکان بازسازی یا تغییر جریان وجود داشته باشد.  
با این حال، غالباً مایلید خرابی به بقیه بلوک‌ها propagate شود ـ این کار در Dataflow پشتیبانی شده و در این حالت Exceptionها به‌صورت تو در تو (AggregateException) منتقل خواهند شد. اگر pipeline طولانی باشد، با Exceptionهایی چندلایه روبرو می‌شوید؛ متد `AggregateException.Flatten` برای ساده‌سازی مدیریت خطا کاربرد دارد:

<div dir="ltr" align="left">

```csharp
try
{
    var multiplyBlock = new TransformBlock<int, int>(item =>
    {
        if (item == 1)
            throw new InvalidOperationException("Blech.");
        return item * 2;
    });

    var subtractBlock = new TransformBlock<int, int>(item => item - 2);

    multiplyBlock.LinkTo(subtractBlock, new DataflowLinkOptions { PropagateCompletion = true });
    multiplyBlock.Post(1);
    subtractBlock.Completion.Wait();
}
catch (AggregateException exception)
{
    AggregateException ex = exception.Flatten();
    Trace.WriteLine(ex.InnerException);
}
```
</div>

(بررسی کامل مدیریت خطا در Recipe 5.2 آمده است.)

---

### مقایسه با Rx و بازیگری (Actor)

در نگاه نخست شاید Dataflow مشابه streamهای observable به نظر برسد، و واقعاً نقاط مشترک زیادی وجود دارد: هر دو مبتنی بر جریان داده، تکمیل عادی (پایان طبیعی داده) و تکمیل خطایی (fault) هستند.  
اما قابلیت‌های Rx و Dataflow یکسان نیست؛  
- **Rx (System.Reactive)** برای سناریوهای زمانی بهتر است  
- **Dataflow** برای پردازش موازی واقعی، قوی‌تر عمل می‌کند.

مفهومی: Rx شبیه اجرای callbackهای متوالی است (هر قدم دستوری، گام بعد را صدا می‌زند)، ولی در Dataflow هر بلوک مستقل است و خودش task جداگانه‌ای برای کار تعریف می‌کند (اعم از اعمال delegate یا ارسال خروجی به بلوک‌های بعدی). حتی می‌توانید هر بلوک را طوری پیکربندی کنید که چند task همزمان اجرا کند ـ شبیه رفتار actorها.

اگر با actor frameworkها آشنا باشید، Dataflow نیز شباهت‌هایی به آن‌ها دارد: هر بلوک Dataflow مستقل است و به شکل مستقل task می‌سازد، اما TPL Dataflow یک actor framework کامل نیست (مثلاً امکانات retry یا بازیابی خطا را ندارد).

---

### انواع پرکاربرد Dataflow Blockها

- **TransformBlock<TInput, TOutput>**  (معادل LINQ: Select)
- **TransformManyBlock<TInput, TOutput>**  (معادل LINQ: SelectMany)
- **ActionBlock<TResult>**  (اجرای delegate برای هر داده)

---

</div>



<div dir="rtl" align="right">

---

## مقدمه‌ای بر برنامه‌نویسی چندریسمانی (Multithreaded Programming)

**Thread** یا رشته، یک مجری مستقل در یک برنامه است. هر فرایند (Process) می‌تواند شامل چندین thread باشد که هرکدام قادرند به‌طور همزمان کارهای متفاوتی انجام ‌دهند. هر thread پشته (Stack) مخصوص به خود دارد، اما حافظه را با سایر threadهای همان فرایند به اشتراک می‌گذارد.  
در برخی برنامه‌ها threadی ویژه وجود دارد؛ مثلاً در نرم‌افزارهای رابط کاربری (UI)، یک thread اصلی مخصوص UI داریم یا در برنامه‌های کنسولی، thread اصلی (main thread) قابل تمایز خواهد بود.

در همه برنامه‌های ‎.NET‎ یک **Thread Pool** وجود دارد که مجموعه‌ای از تردهای worker را نگهداری می‌کند تا به محض نیاز کار جدید را اجرا کنند.  
اندازه Thread Pool و تعداد threadها به صورت هوشمند و خودکار مدیریت می‌شود و معمولاً بهتر است آن را به حال خود رها کنید؛ این سیستم برای اغلب سناریوهای واقعی بهینه شده است.

**در عصر حاضر، تقریباً هیچ نیازی به ساخت thread جدید به‌دست خودتان نیست.**  
تنها استثنا زمانی است که نیاز به تعامل با COM و یک thread با STA داشته باشید.

Thread یک انتزاع سطح پایین است. Thread Pool سطح بالاتری از انتزاع را ارائه می‌دهد و کافی است کار را صف‌بندی (enqueue) کنید تا Thread Pool مدیریت تخصیص thread را انجام دهد. انتزاع‌هایی که در این کتاب آموزش داده می‌شوند (مانند پردازش موازی یا Dataflow) حتی سطح بالاتر هستند: کار را به Thread Pool واگذار می‌کنند و فرآیند کدنویسی به‌مراتب آسان‌تر و ایمن‌تر خواهد بود.

**بنابراین، آموزش این کتاب بر مبنای Thread یا BackgroundWorker نیست**؛  
این ابزارها اکنون منسوخ به حساب می‌آیند.

---

## کالکشن‌های مورد نیاز برای برنامه‌های همروند

برای توسعه برنامه‌های concurrent (همروند) به دو دسته کالکشن کاربردی نیاز خواهید داشت:

۱. **کالکشن‌های Concurrent:**  
به چندین thread اجازه می‌دهند تا به‌شکل امن و همزمان مقادیر را به کالکشن اضافه یا حذف کنند. اغلب هنگام پیمایش (Enumeration) نیز threadهای دیگر می‌توانند به اقدامات افزودن یا حذف ادامه دهند، در حالی که thread جاری در حال پیمایش است. این ساختارها، معمولاً بسیار بهینه‌تر از محافظت یک کالکشن معمولی با lock هستند.

۲. **کالکشن‌های Immutable:**  
این کالکشن‌ها پس از ساخته‌شدن قابل تغییر نیستند؛ بلکه برای اعمال هرگونه تغییر باید نمونه جدیدی بسازید که نماینده حالت تغییر یافته است.  
با‌ آنکه چنین رویکردی ناکارآمد به‌نظر می‌رسد، اما این ساختارها بیشترین اشتراک حافظه ممکن را میان نمونه‌ها دارند و عملکرد مناسبی دارند.  
مزیت بزرگ دیگر آن‌ها «اعمال بودن همه عملیات» (بدون Side Effect) است و با سبک برنامه‌نویسی تابعی (Functional) هماهنگی کامل دارند.

---

## سبک طراحی مدرن در برنامه‌نویسی همروند

اغلب فناوری‌های concurrent ماهیتی تابعی (Functional) دارند؛ یعنی تأکید بر ترکیب توابع دارند.  
با کسب ذهنیت تابعی، طراحی‌های همزمان شما ساختارمندتر و کم‌اشتباه‌تر خواهد بود.

اصلی‌ترین مؤلفه برنامه‌نویسی تابعی **خلوص (Purity)** است؛ یعنی پرهیز از عوارض جانبی (Side Effect). هر بخش کد، فقط ورودی و خروجی دارد و از داده‌های shared/global حتی‌المقدور دوری می‌کند. این اصل برای async methodها، کارهای موازی، عملیات Rx یا blockهای Dataflow نیز کاربرد مستقیم دارد.  
البته اجرای فعالیت‌های خارجی روزی باید رخ دهد، اما چنانچه بیشترین بخش کدهای خود را «خالص» بنویسید و اثر جانبی را فقط به مراحل پایانی محدود کنید، کدی تمیزتر و قابل نگهداری‌تر خواهید داشت.

یکی دیگر از اصول مهم، **تغییرناپذیری (Immutability)** است؛ به این معنی که داده‌ای ایجاد کنید که دیگر تغییر نکند. داده‌های immutable نیازی به همگام‌سازی میان threadها ندارند و این شما را از بسیاری مشکلات concurrentی رها می‌کند. استفاده از انواع immutable رو به گسترش است و این کتاب نیز به آن می‌پردازد.

---

## جمع‌بندی فناوری‌های کلیدی همزمانی و همروندی در ‎#C‎

- **برنامه‌نویسی ناهمگام:**  
  از همان نسخه‌های ابتدایی دات‌نت پشتیبانی می‌شود؛ اما تا قبل از ‎.NET 4.5‎ (۲۰۱۲) و معرفی ‎async/await‎، استفاده از آن دشوار بود. این کتاب مبتنی بر تکنیک‌های async/await است و تعامل با الگوهای قدیمی‌تر را هم بررسی می‌کند (برای پلتفرم‌های قدیمی‌تر، پیوست A را ببینید).

- **کتابخانه موازی‌سازی وظیفه‌ای (Task Parallel Library – TPL):**  
  از ‎.NET 4.0‎ برای موازی‌سازی داده‌ای و وظیفه‌ای در دسترس است و حتی برای پلتفرم‌های کم‌منبع نیز مناسب است. این کتابخانه بخشی از ‎.NET‎ است.

- **System.Reactive:**  
  با فلسفه پوشش حداکثری پلتفرم‌ها توسعه یافته و مشابه async/await به کلاینت و سرور مزیت می‌دهد. این کتابخانه با پکیج NuGet با همین نام قابل نصب است.

- **TPL Dataflow:**  
  به صورت رسمی از طریق پکیج NuGet با نام ‎System.Threading.Tasks.Dataflow‎ عرضه می‌شود.

- **کالکشن‌های concurrent:**  
  عمدتاً در خود ‎.NET‎ تعبیه شده‌اند، اما اگر امکانات بیشتر نیاز دارید می‌توانید پکیج ‎System.Threading.Channels‎ را نیز فعال نمایید.

- **کالکشن‌های immutable:**  
  از طریق پکیج ‎System.Collections.Immutable‎ قابل استفاده هستند.

---

</div>
